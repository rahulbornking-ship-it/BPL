// DSA Patterns Data - Auto-generated and Updated
// Contains 30 patterns

export const dsaPatterns = [
  {
    "id": "pattern-1",
    "name": "Two Pointers",
    "slug": "two-pointers",
    "icon": "ðŸ‘†",
    "description": "Master the Two Pointers pattern",
    "items": [
      {
        "id": "two-pointer-theory",
        "title": "Two Pointer Pattern Theory",
        "slug": "two-pointer-theory",
        "difficulty": "theory",
        "isTheory": true,
        "patternSlug": "two-pointers",
        "lectureNotesSvg": "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/1_Day/1_Two_Pointer_Pattern_Theory.excalidraw.svg",
        "theory": {
          "explanation": "The Two Pointer pattern uses two pointers to traverse an array or list, typically moving towards each other or in the same direction. This technique is commonly used for problems involving pairs, sorted arrays, or when comparing elements from both ends.",
          "whenToUse": [
            "Sorted arrays where you need to find pairs",
            "Problems involving palindromes",
            "Merging two sorted arrays",
            "Removing duplicates from sorted arrays",
            "Container With Most Water type problems"
          ],
          "intuition": "Instead of using nested loops (O(nÂ²)), use two pointers that move based on conditions, reducing time complexity to O(n). Think of it as narrowing down the search space by eliminating impossible options.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty array",
            "Single element",
            "All elements same",
            "Already sorted array"
          ]
        },
        "solutions": {
          "code": {
            "java": "// Generic Two Pointers Template\npublic void twoPointers(int[] arr) {\n    int left = 0;\n    int right = arr.length - 1;\n    while (left < right) {\n        if (condition) left++;\n        else right--;\n    }\n}",
            "cpp": "// Generic Two Pointers Template\nvoid twoPointers(vector<int>& arr) {\n    int left = 0;\n    int right = arr.length - 1;\n    while (left < right) {\n        if (condition) left++;\n        else right--;\n    }\n}"
          }
        }
      },
      {
        "id": "two-2",
        "title": "Valid Palindrome",
        "slug": "valid-palindrome",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/valid-palindrome/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0;\n        int j = s.length() - 1;\n\n        while (i < j) {\n            char left = s[i];\n            char right = s[j];\n\n            if (!isalnum(left)) {\n                i++;\n                continue;\n            }\n\n            if (!isalnum(right)) {\n                j--;\n                continue;\n            }\n\n            if (tolower(left) != tolower(right)) {\n                return false;\n            }\n\n            i++;\n            j--;\n        }\n\n        return true;\n    }\n};",
            "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0,\n            j = s.length() - 1;\n\n        while (i < j) {\n            char left = s.charAt(i);\n            char right = s.charAt(j);\n\n            if (!Character.isLetterOrDigit(left)) {\n                i = i + 1;\n                continue;\n            }\n\n            if (!Character.isLetterOrDigit(right)) {\n                j = j - 1;\n                continue;\n            }\n\n            if (Character.toLowerCase(left) != Character.toLowerCase(right)) {\n                return false;\n            }\n\n            i = i + 1;\n            j = j - 1;\n        }\n\n        return true;\n    }\n}",
            "python": "# Python Solution for Valid Palindrome\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"A man, a plan, a canal: Panama\"\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \"amanaplanacanalpanama\" is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"race a car\"\n<strong>Output:</strong> false\n<strong>Explanation:</strong> \"raceacar\" is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \" \"\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>"
      },
      {
        "id": "two-18",
        "title": "Reverse String",
        "slug": "reverse-string",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/reverse-string/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int i = 0;\n        int j = s.size() - 1;\n        while (i < j) {\n            swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n};",
            "java": "class Solution {\n    public void reverseString(char[] s) {\n        int i = 0;\n        int j = s.length - 1;\n        while (i < j) {\n            char temp = s[i];\n            s[i] = s[j];\n            s[j] = temp;\n            i++;\n            j--;\n        }\n    }\n}",
            "python": "# Python Solution for Reverse String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>"
      },
      {
        "id": "two-17",
        "title": "Squares of a Sorted Array",
        "slug": "squares-of-a-sorted-array",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/squares-of-a-sorted-array/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        int i = 0, j = n - 1, k = n - 1;\n        \n        while (i <= j) {\n            if (abs(nums[i]) > abs(nums[j])) {\n                res[k] = nums[i] * nums[i];\n                i++;\n            } else {\n                res[k] = nums[j] * nums[j];\n                j--;\n            }\n            k--;\n        }\n        return res;\n    }\n};",
            "java": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int[] res = new int[nums.length];\n        \n        int i = 0;\n        int j = nums.length - 1;\n        int k = nums.length - 1;\n        \n        while (i <= j) {\n            if (Math.abs(nums[i]) > Math.abs(nums[j])) {\n                res[k] = nums[i] * nums[i];\n                i = i + 1;\n            } else {\n                res[k] = nums[j] * nums[j];\n                j = j - 1;\n            }\n            k = k - 1;\n        }\n        \n        return res;\n    }\n}",
            "python": "# Python Solution for Squares of a Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [-4,-1,0,3,10]\n<strong>Output:</strong> [0,1,9,16,100]\n<strong>Explanation:</strong> After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [-7,-3,2,3,11]\n<strong>Output:</strong> [4,9,9,49,121]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Squaring each element and sorting the new array is very trivial, could you find an <code>O(n)</code> solution using a different approach?"
      },
      {
        "id": "two-19",
        "title": "Valid Palindrome II",
        "slug": "valid-palindrome-ii",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/valid-palindrome-ii/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool palindromeHelper(int i, int j, string& s) {\n        while (i < j) {\n            if (s[i] != s[j]) return false;\n            i++; j--;\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (s[i] != s[j]) {\n                return palindromeHelper(i + 1, j, s) || palindromeHelper(i, j - 1, s);\n            }\n            i++; j--;\n        }\n        return true;\n    }\n};",
            "java": "class Solution {\n    public boolean palindromeHelper(int i, int j, String s) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n            i = i + 1;\n            j = j - 1;\n        }\n        return true;\n    }\n\n    public boolean validPalindrome(String s) {\n        int i = 0;\n        int j = s.length() - 1;\n        \n        while (i < j) {\n            char left = s.charAt(i);\n            char right = s.charAt(j);\n            \n            if (left != right) {\n                return palindromeHelper(i + 1, j, s) || palindromeHelper(i, j - 1, s);\n            } else {\n                i = i + 1;\n                j = j - 1;\n            }\n        }\n        \n        return true;\n    }\n}",
            "python": "# Python Solution for Valid Palindrome II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a string <code>s</code>, return <code>true</code> <em>if the </em><code>s</code><em> can be palindrome after deleting <strong>at most one</strong> character from it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"aba\"\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"abca\"\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You could delete the character 'c'.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"abc\"\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>"
      },
      {
        "id": "two-11",
        "title": "Valid Word Abbreviation",
        "slug": "valid-word-abbreviation",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/valid-word-abbreviation/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool validWordAbbreviation(string word, string abbr) {\n        int i = 0, j = 0;\n        while (i < word.length() && j < abbr.length()) {\n            if (isdigit(abbr[j])) {\n                if (abbr[j] == '0') return false;\n                int val = 0;\n                while (j < abbr.length() && isdigit(abbr[j])) {\n                    val = val * 10 + (abbr[j] - '0');\n                    j++;\n                }\n                i += val;\n            } else {\n                if (word[i] != abbr[j]) return false;\n                i++;\n                j++;\n            }\n        }\n        return i == word.length() && j == abbr.length();\n    }\n};",
            "java": "class Solution {\n    public boolean validWordAbbreviation(String word, String abbr) {\n        int i = 0;\n        int j = 0;\n        \n        while (i < word.length() && j < abbr.length()) {\n            char w_c = word.charAt(i);\n            char a_c = abbr.charAt(j);\n            \n            if (Character.isDigit(a_c)) {\n                if (a_c == '0') {\n                    return false; \n                }\n                \n                int curr = 0;\n                while (j < abbr.length() && Character.isDigit(abbr.charAt(j))) {\n                    curr = curr * 10 + (abbr.charAt(j) - '0');\n                    j = j + 1;\n                }\n                \n                i = i + curr;\n            } else {\n                if (w_c != a_c) {\n                    return false;\n                }\n                i = i + 1;\n                j = j + 1;\n            }\n        }\n        \n        return i == word.length() && j == abbr.length();\n    }\n}",
            "python": "# Python Solution for Valid Word Abbreviation\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>A string can be <strong>abbreviated</strong> by replacing any number of <strong>non-adjacent</strong>, <strong>non-empty</strong> substrings with their lengths. The lengths should not have leading zeros.</p>\n\n<p>For example, a string such as <code>\"substitution\"</code> could be abbreviated as (but not limited to):</p>\n<ul>\n\t<li><code>\"s10n\"</code> (<code>\"s ubstitutio n\"</code>)</li>\n\t<li><code>\"sub4u4\"</code> (<code>\"sub stit u tion\"</code>)</li>\n\t<li><code>\"12\"</code> (<code>\"substitution\"</code>)</li>\n\t<li><code>\"su3i1u2on\"</code> (<code>\"su bst i t u ti on\"</code>)</li>\n\t<li><code>\"substitution\"</code> (no substrings replaced)</li>\n</ul>\n\n<p>The following are <strong>not</strong> valid abbreviations:</p>\n<ul>\n\t<li><code>\"s55n\"</code> (<code>\"s ubsti tutio n\"</code>, the replaced substrings are adjacent)</li>\n\t<li><code>\"s010n\"</code> (has leading zeros)</li>\n\t<li><code>\"s0ubstitution\"</code> (replaces an empty substring)</li>\n</ul>\n\n<p>Given a string <code>word</code> and an abbreviation <code>abbr</code>, return whether the string matches the given abbreviation.</p>\n\n<p>A <strong>substring</strong> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> word = \"internationalization\", abbr = \"i12iz4n\"\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The word \"internationalization\" can be abbreviated as \"i12iz4n\" (\"i nternational iz atio n\").\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> word = \"apple\", abbr = \"a2e\"\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The word \"apple\" cannot be abbreviated as \"a2e\".\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 20</code></li>\n\t<li><code>word</code> consists of only lowercase English letters.</li>\n\t<li><code>1 &lt;= abbr.length &lt;= 10</code></li>\n\t<li><code>abbr</code> consists of lowercase English letters and digits.</li>\n\t<li>All the integers in <code>abbr</code> will fit in a 32-bit integer.</li>\n</ul>"
      },
      {
        "id": "two-1",
        "title": "Merge Sorted Array",
        "slug": "merge-sorted-array",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/merge-sorted-array/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        \n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};",
            "java": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i];\n                i = i - 1;\n            } else {\n                nums1[k] = nums2[j];\n                j = j - 1;\n            }\n            k = k - 1;\n        }\n\n        while (j >= 0) {\n            nums1[k] = nums2[j];\n            k = k - 1;\n            j = j - 1;\n        }\n    }\n}",
            "python": "# Python Solution for Merge Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>\n\n<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>\n\n<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array </em><code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>Output:</strong> [1,2,2,3,5,6]\n<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>"
      },
      {
        "id": "two-20",
        "title": "Count Pairs Whose Sum is Less than Target",
        "slug": "count-pairs-whose-sum-is-less-than-target",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int countPairs(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int i = 0, j = nums.size() - 1;\n        int count = 0;\n        \n        while (i < j) {\n            if (nums[i] + nums[j] < target) {\n                count += (j - i);\n                i++;\n            } else {\n                j--;\n            }\n        }\n        return count;\n    }\n};",
            "java": "class Solution {\n    public int countPairs(List<Integer> nums, int target) {\n        Collections.sort(nums);\n\n        int i = 0;\n        int j = nums.size() - 1;\n        int count = 0;\n\n        while (i < j) {\n            int sum = nums.get(i) + nums.get(j);\n\n            if (sum < target) {\n                count = count + (j - i);\n                i = i + 1;\n            } else {\n                j = j - 1;\n            }\n        }\n        return count;\n    }\n}",
            "python": "# Python Solution for Count Pairs Whose Sum is Less than Target\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "Given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, return <em>the number of pairs</em> <code>(i, j)</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; n</code> <em>and</em> <code>nums[i] + nums[j] &lt; target</code>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [-1,1,2,3,1], target = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are 3 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = 0 &lt; target\n- (0, 2) since 0 &lt; 2 and nums[0] + nums[2] = 1 &lt; target \n- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = 0 &lt; target\nNote that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [-6,2,5,-2,-7,-1,3], target = -2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> There are 10 pairs of indices that satisfy the conditions in the statement:\n- (0, 1) since 0 &lt; 1 and nums[0] + nums[1] = -4 &lt; target\n- (0, 3) since 0 &lt; 3 and nums[0] + nums[3] = -8 &lt; target\n- (0, 4) since 0 &lt; 4 and nums[0] + nums[4] = -13 &lt; target\n- (0, 5) since 0 &lt; 5 and nums[0] + nums[5] = -7 &lt; target\n- (0, 6) since 0 &lt; 6 and nums[0] + nums[6] = -3 &lt; target\n- (1, 4) since 1 &lt; 4 and nums[1] + nums[4] = -5 &lt; target\n- (3, 4) since 3 &lt; 4 and nums[3] + nums[4] = -9 &lt; target\n- (3, 5) since 3 &lt; 5 and nums[3] + nums[5] = -3 &lt; target\n- (4, 5) since 4 &lt; 5 and nums[4] + nums[5] = -8 &lt; target\n- (4, 6) since 4 &lt; 6 and nums[4] + nums[6] = -4 &lt; target\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>-50 &lt;= nums[i], target &lt;= 50</code></li>\n</ul>"
      },
      {
        "id": "two-21",
        "title": "Two Sum",
        "slug": "two-sum",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/two-sum/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            int lookingFor = target - nums[i];\n            if (map.find(lookingFor) != map.end()) {\n                return {map[lookingFor], i};\n            }\n            map[nums[i]] = i;\n        }\n        return {-1, -1};\n    }\n};",
            "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i = i + 1) {\n            int lookingFor = target - nums[i];\n\n            if (map.containsKey(lookingFor)) {\n                return new int[] {\n                    map.get(lookingFor),\n                    i\n                };\n            }\n\n            map.put(nums[i], i);\n        }\n\n        return new int[] {\n            -1, -1\n        };\n    }\n}",
            "python": "# Python Solution for Two Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>"
      },
      {
        "id": "two-22",
        "title": "Two Sum II - Input Array Is Sorted",
        "slug": "two-sum-ii-input-array-is-sorted",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int i = 0;\n        int j = numbers.size() - 1;\n\n        while (i < j) {\n            int sum = numbers[i] + numbers[j];\n\n            if (sum > target) {\n                j--;\n            } else if (sum < target) {\n                i++;\n            } else {\n                return {i + 1, j + 1};\n            }\n        }\n\n        return {-1, -1};\n    }\n};",
            "java": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int i = 0,\n            j = numbers.length - 1;\n\n        while (i < j) {\n            int sum = numbers[i] + numbers[j];\n\n            if (sum > target) {\n                j = j - 1;\n            } else if (sum < target) {\n                i = i + 1;\n            } else {\n                return new int[] {\n                    i + 1,\n                    j + 1\n                };\n            }\n        }\n\n        return new int[] {\n            -1, -1\n        };\n    }\n}",
            "python": "# Python Solution for Two Sum II - Input Array Is Sorted\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>"
      },
      {
        "id": "two-3",
        "title": "3Sum",
        "slug": "3sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/3sum/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void twoSumHelper(int f, vector<int>& nums, vector<vector<int>>& res) {\n        int i = f + 1;\n        int j = nums.size() - 1;\n\n        while (i < j) {\n            int sum = nums[f] + nums[i] + nums[j];\n\n            if (sum > 0) {\n                j--;\n            } else if (sum < 0) {\n                i++;\n            } else {\n                res.push_back({nums[f], nums[i], nums[j]});\n                i++;\n                j--;\n\n                while (i < j && nums[i] == nums[i - 1]) {\n                    i++;\n                }\n\n                while (i < j && nums[j] == nums[j + 1]) {\n                    j--;\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> res;\n\n        for (int f = 0; f < nums.size(); f++) {\n            if (nums[f] > 0) {\n                break;\n            }\n\n            if (f == 0 || nums[f] != nums[f - 1]) {\n                twoSumHelper(f, nums, res);\n            }\n        }\n\n        return res;\n    }\n};",
            "java": "class Solution {\n    public void twoSumHelper(int f, int[] nums, List<List<Integer>> res) {\n        int i = f + 1,\n            j = nums.length - 1;\n\n        while (i < j) {\n            int sum = nums[f] + nums[i] + nums[j];\n\n            if (sum > 0) {\n                j = j - 1;\n            } else if (sum < 0) {\n                i = i + 1;\n            } else {\n                res.add(Arrays.asList(nums[f], nums[i], nums[j]));\n                i = i + 1;\n                j = j - 1;\n\n                while (i < j && nums[i] == nums[i - 1]) {\n                    i = i + 1;\n                }\n\n                while (i < j && nums[j] == nums[j + 1]) {\n                    j = j - 1;\n                }\n            }\n        }\n    }\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n\n        List<List<Integer>> res = new ArrayList<>();\n\n        for (int f = 0; f < nums.length; f = f + 1) {\n            if (nums[f] > 0) {\n                break;\n            }\n\n            if (f == 0 || nums[f] != nums[f - 1]) {\n                 twoSumHelper(f, nums, res);\n            }\n        }\n\n        return res;\n    }\n}",
            "python": "# Python Solution for 3Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>"
      },
      {
        "id": "two-23",
        "title": "Sort Two Colors",
        "slug": "sort-two-colors",
        "difficulty": "medium",
        "externalLink": "https://www.programiz.com/java-programming/online-compiler/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void sortTwoColors(vector<int>& nums) {\n        // Sort array of 0s and 1s\n        // T: O(n), S: O(1)\n        int i = 0, j = nums.size() - 1;\n        \n        while (i <= j) {\n            if (nums[i] == 0) {\n                i++;\n            } else {\n                swap(nums[i], nums[j]);\n                j--;\n            }\n        }\n    }\n};",
            "java": "class Solution {\n    public void sortTwoColors(int[] nums) {\n        // nums -> sort two colors in nums array\n        int i = 0,\n            j = nums.length - 1;\n\n        // T: O(n), S: O(1)\n        // 0 0 1\n        //     i.  \n        //   j\n        while (i <= j) {\n            if (nums[i] == 0) {\n                i = i + 1;\n            } else {\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                \n                j = j - 1;\n            }\n        }\n    }\n}"
          }
        },
        "description": "<p>Given an array of only 0s and 1s, sort them in-place so that all 0s come before all 1s.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums = [1,0,1,0,0,1]\n<strong>Output:</strong> [0,0,0,1,1,1]\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [0,1]\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 300</code></li><li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li></ul>"
      },
      {
        "id": "two-5",
        "title": "Sort Colors",
        "slug": "sort-colors",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/sort-colors/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        // Dutch National Flag problem: Sort 0s, 1s, 2s\n        // T: O(n), S: O(1)\n        int i = 0, j = nums.size() - 1, k = 0;\n        \n        while (k <= j) {\n            if (nums[k] == 1) {\n                k++;\n            } else if (nums[k] == 2) {\n                swap(nums[k], nums[j]);\n                j--;\n            } else {\n                swap(nums[i], nums[k]);\n                i++;\n                k++;\n            }\n        }\n    }\n};",
            "java": "class Solution {\n    public void sortColors(int[] nums) {\n        int i = 0,\n            j = nums.length - 1,\n            k = 0;\n        // 0 0 1 1 2 2\n        //     i\n        //       j\n        //         k\n        while (k <= j) {\n            // T: O(n), S: O(1)\n            if (nums[k] == 1) {\n                k = k + 1;\n            } else if (nums[k] == 2) {\n                int temp = nums[j];\n                nums[j] = nums[k];\n                nums[k] = temp;\n\n                j = j - 1;\n            } else {\n                int temp = nums[i];\n                nums[i] = nums[k];\n                nums[k] = temp;\n\n                i = i + 1;\n                k = k + 1; \n            }\n        }\n    }\n}"
          }
        },
        "description": "<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>\n\n<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>\n\n<p>You must solve this problem without using the library's sort function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [2,0,2,1,1,0]\n<strong>Output:</strong> [0,0,1,1,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [2,0,1]\n<strong>Output:</strong> [0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>"
      },
      {
        "id": "two-4",
        "title": "Remove Nth Node From End of List",
        "slug": "remove-nth-node-from-end-of-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* start = new ListNode();\n        start->next = head;\n        ListNode* fast = start;\n        ListNode* slow = start;\n\n        for (int i = 1; i <= n; ++i)\n            fast = fast->next;\n\n        while (fast->next != NULL) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        slow->next = slow->next->next;\n        return start->next;\n    }\n};",
            "java": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;\n\n        for (int i = 1; i <= n; ++i)\n            fast = fast.next;\n\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n\n        slow.next = slow.next.next;\n        return start.next;\n    }\n}"
          }
        },
        "description": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\">\n<pre><strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>"
      },
      {
        "id": "two-12",
        "title": "Strobogrammatic Number",
        "slug": "strobogrammatic-number",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/strobogrammatic-number/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool isStrobogrammatic(string num) {\n        unordered_map<char, char> map = {\n            {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}\n        };\n        \n        int i = 0;\n        int j = num.length() - 1;\n        while (i <= j) {\n            if (map.find(num[i]) == map.end() || map[num[i]] != num[j]) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n};",
            "java": "public static boolean isStrobogrammaticNumber(Map<Character, Character> map, String s) {\n    int i = 0;\n    int j = s.length() - 1;\n    \n    while (i <= j) {\n        char l = s.charAt(i);\n        char r = s.charAt(j);\n        \n        if (map.containsKey(l)) {\n            if (map.get(l) != r) {\n                return false;\n            }\n        } else {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}"
          }
        },
        "description": "<p>Given a string <code>num</code> which represents an integer, return <code>true</code> <em>if</em> <code>num</code> <em>is a <strong>strobogrammatic number</strong></em>.</p><p>A <strong>strobogrammatic number</strong> is a number that looks the same when rotated <code>180</code> degrees (looked at upside down).</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> num = \"69\"\n<strong>Output:</strong> true\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> num = \"88\"\n<strong>Output:</strong> true\n</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> num = \"962\"\n<strong>Output:</strong> false\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= num.length &lt;= 50</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>num</code> does not contain any leading zeros except for zero itself.</li>\n</ul>"
      },
      {
        "id": "two-16",
        "title": "Append Characters to String to Make Subsequence",
        "slug": "append-characters-to-string-to-make-subsequence",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int appendCharacters(string s, string t) {\n        int i = 0, j = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s[i] == t[j]) {\n                j++;\n            }\n            i++;\n        }\n        return t.length() - j;\n    }\n};",
            "java": "class Solution {\n    public int appendCharacters(String s, String t) {\n        int i = 0;\n        int j = 0;\n        \n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                j++;\n            }\n            i++;\n        }\n        return t.length() - j;\n    }\n}"
          }
        },
        "description": "<p>You are given two strings <code>s</code> and <code>t</code> consisting of only lowercase English letters.</p>\n\n<p>Return <em>the minimum number of characters that need to be appended to the end of </em><code>s</code><em> so that </em><code>t</code><em> becomes a <strong>subsequence</strong> of </em><code>s</code>.</p>\n\n<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"coaching\", t = \"coding\"\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Append the characters \"ding\" to the end of s so that s = \"coachingding\".\nNow, t is a subsequence of s (\"<u><strong>co</strong></u>aching<u><strong>ding</strong></u>\").\nIt can be shown that appending any 3 characters to the end of s will never make t a subsequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"abcde\", t = \"a\"\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> t is already a subsequence of s (\"<u><strong>a</strong></u>bcde\").\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"z\", t = \"abcde\"\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Append the characters \"abcde\" to the end of s so that s = \"zabcde\".\nNow, t is a subsequence of s (\"z<u><strong>abcde</strong></u>\").\nIt can be shown that appending any 4 characters to the end of s will never make t a subsequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>"
      },
      {
        "id": "two-14",
        "title": "Lowest Common Ancestor of a Binary Tree III",
        "slug": "lowest-common-ancestor-of-a-binary-tree-iii",
        "difficulty": "medium",
        "externalLink": "https://neetcode.io/problems/lowest-common-ancestor-of-a-binary-tree-iii",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    Node* lowestCommonAncestor(Node* p, Node* q) {\n        Node* p1 = p;\n        Node* q1 = q;\n        \n        while (p1 != q1) {\n            p1 = (p1 == nullptr) ? q : p1->parent;\n            q1 = (q1 == nullptr) ? p : q1->parent;\n        }\n        return p1;\n    }\n};",
            "java": "class Solution {\n    public Node lowestCommonAncestor(Node p, Node q) {\n        Node p1 = p;\n        Node q1 = q;\n        \n        while (p1 != q1) {\n            p1 = (p1 == null) ? q : p1.parent;\n            q1 = (q1 == null) ? p : q1.parent;\n        }\n        return p1;\n    }\n}"
          }
        },
        "description": "<p>Given two nodes of a binary tree <code>p</code> and <code>q</code>, return <em>their lowest common ancestor (LCA)</em>.</p><p>Each node will have a reference to its parent node. The definition for <code>Node</code> is below:</p><pre>class Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n</pre><p>According to the <strong><a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" rel=\"nofollow\">definition of LCA on Wikipedia</a></strong>: \"The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow <b>a node to be a descendant of itself</b>).\"</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li><li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li><li>All <code>Node.val</code> are <strong>unique</strong>.</li><li><code>p != q</code></li><li><code>p</code> and <code>q</code> exist in the tree.</li></ul>"
      },
      {
        "id": "two-6",
        "title": "Reverse Words in a String",
        "slug": "reverse-words-in-a-string",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reverse-words-in-a-string/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    string reverseWords(string s) {\n        stringstream ss(s);\n        string word;\n        vector<string> words;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        reverse(words.begin(), words.end());\n        string res;\n        for (int i = 0; i < words.size(); ++i) {\n            if (i > 0) res += \" \";\n            res += words[i];\n        }\n        return res;\n    }\n};",
            "java": "class Solution {\n    public String reverseWords(String s) {\n        String trim = s.trim();\n        String[] arr = trim.split(\"\\\\s+\");\n        \n        int i = 0;\n        int j = arr.length - 1;\n        \n        while (i < j) {\n            String temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n        \n        return String.join(\" \", arr);\n    }\n}"
          }
        },
        "description": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"the sky is blue\"\n<strong>Output:</strong> \"blue is sky the\"\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"  hello world  \"\n<strong>Output:</strong> \"world hello\"\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"a good   example\"\n<strong>Output:</strong> \"example good a\"\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>' '</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>"
      },
      {
        "id": "two-7",
        "title": "Minimum Number of Moves to Make Palindrome",
        "slug": "minimum-number-of-moves-to-make-palindrome",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Number of Moves to Make Palindrome\nclass Solution {\npublic:\n    int minMovesToMakePalindrome(string s) {\n        int n = s.length();\n        int l = 0, r = n - 1;\n        int ans = 0;\n        while (l < r) {\n            int k = r;\n            while (k > l && s[k] != s[l]) {\n                k--;\n            }\n            if (k == l) {\n                swap(s[l], s[l+1]);\n                ans++;\n            } else {\n                while (k < r) {\n                    swap(s[k], s[k+1]);\n                    k++;\n                    ans++;\n                }\n                l++;\n                r--;\n            }\n        }\n        return ans;\n    }\n};",
            "java": "// Java Solution for Minimum Number of Moves to Make Palindrome\nclass Solution {\n    public int minMovesToMakePalindrome(String s) {\n        int n = s.length();\n        int l = 0, r = n - 1;\n        int ans = 0;\n        char[] arr = s.toCharArray();\n        \n        while (l < r) {\n            int k = r;\n            while (k > l && arr[k] != arr[l]) {\n                k--;\n            }\n            if (k == l) {\n                swap(arr, l, l + 1);\n                ans++;\n            } else {\n                while (k < r) {\n                    swap(arr, k, k + 1);\n                    k++;\n                    ans++;\n                }\n                l++;\n                r--;\n            }\n        }\n        return ans;\n    }\n    private void swap(char[] arr, int i, int j) {\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}"
          }
        },
        "description": "<p>You are given a string <code>s</code> consisting only of lowercase English letters.</p>\n\n<p>In one <strong>move</strong>, you can select any two <strong>adjacent</strong> characters of <code>s</code> and swap them.</p>\n\n<p>Return <em>the <strong>minimum number of moves</strong> needed to make</em> <code>s</code> <em>a palindrome</em>.</p>\n\n<p><strong>Note</strong> that the input will be generated such that <code>s</code> can always be converted to a palindrome.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can obtain two palindromes from s, &quot;abba&quot; and &quot;baab&quot;. \n- We can obtain &quot;abba&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;ab<u><strong>ab</strong></u>&quot; -&gt; &quot;abba&quot;.\n- We can obtain &quot;baab&quot; from s in 2 moves: &quot;a<u><strong>ab</strong></u>b&quot; -&gt; &quot;<u><strong>ab</strong></u>ab&quot; -&gt; &quot;baab&quot;.\nThus, the minimum number of moves needed to make s a palindrome is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;letelt&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nOne of the palindromes we can obtain from s in 2 moves is &quot;lettel&quot;.\nOne of the ways we can obtain it is &quot;lete<u><strong>lt</strong></u>&quot; -&gt; &quot;let<u><strong>et</strong></u>l&quot; -&gt; &quot;lettel&quot;.\nOther palindromes such as &quot;tleelt&quot; can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n\t<li><code>s</code> can be converted to a palindrome using a finite number of moves.</li>\n</ul>\n"
      },
      {
        "id": "two-8",
        "title": "Count Subarrays With Fixed Bounds",
        "slug": "count-subarrays-with-fixed-bounds",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/count-subarrays-with-fixed-bounds/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Subarrays With Fixed Bounds\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int minK, int maxK) {\n        long long ans = 0;\n        int minI = -1, maxI = -1, badI = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] < minK || nums[i] > maxK) badI = i;\n            if (nums[i] == minK) minI = i;\n            if (nums[i] == maxK) maxI = i;\n            ans += max(0, min(minI, maxI) - badI);\n        }\n        return ans;\n    }\n};",
            "java": "// Java Solution for Count Subarrays With Fixed Bounds\nclass Solution {\n    public long countSubarrays(int[] nums, int minK, int maxK) {\n        long ans = 0;\n        int minI = -1, maxI = -1, badI = -1;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] < minK || nums[i] > maxK) badI = i;\n            if (nums[i] == minK) minI = i;\n            if (nums[i] == maxK) maxI = i;\n            ans += Math.max(0, Math.min(minI, maxI) - badI);\n        }\n        return ans;\n    }\n}"
          }
        },
        "description": "<p>You are given an integer array <code>nums</code> and two integers <code>minK</code> and <code>maxK</code>.</p>\n\n<p>A <strong>fixed-bound subarray</strong> of <code>nums</code> is a subarray that satisfies the following conditions:</p>\n\n<ul>\n\t<li>The <strong>minimum</strong> value in the subarray is equal to <code>minK</code>.</li>\n\t<li>The <strong>maximum</strong> value in the subarray is equal to <code>maxK</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>number</strong> of fixed-bound subarrays</em>.</p>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,2,7,5], minK = 1, maxK = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The fixed-bound subarrays are [1,3,5] and [1,3,5,2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1], minK = 1, maxK = 1\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], minK, maxK &lt;= 10<sup>6</sup></code></li>\n</ul>\n"
      },
      {
        "id": "two-9",
        "title": "Get the Maximum Score",
        "slug": "get-the-maximum-score",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/get-the-maximum-score/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Get the Maximum Score\nclass Solution {\npublic:\n    int maxSum(vector<int>& nums1, vector<int>& nums2) {\n        long long sum1 = 0, sum2 = 0;\n        int i = 0, j = 0;\n        int n = nums1.size(), m = nums2.size();\n        long long mod = 1e9 + 7;\n        while (i < n && j < m) {\n            if (nums1[i] < nums2[j]) {\n                sum1 += nums1[i++];\n            } else if (nums1[i] > nums2[j]) {\n                sum2 += nums2[j++];\n            } else {\n                long long best = max(sum1, sum2) + nums1[i];\n                sum1 = best;\n                sum2 = best;\n                i++; j++;\n            }\n        }\n        while (i < n) sum1 += nums1[i++];\n        while (j < m) sum2 += nums2[j++];\n        return max(sum1, sum2) % mod;\n    }\n};",
            "java": "// Java Solution for Get the Maximum Score\nclass Solution {\n    public int maxSum(int[] nums1, int[] nums2) {\n        long sum1 = 0, sum2 = 0;\n        int i = 0, j = 0;\n        int n = nums1.length, m = nums2.length;\n        long mod = 1_000_000_007;\n        while (i < n && j < m) {\n            if (nums1[i] < nums2[j]) {\n                sum1 += nums1[i++];\n            } else if (nums1[i] > nums2[j]) {\n                sum2 += nums2[j++];\n            } else {\n                long best = Math.max(sum1, sum2) + nums1[i];\n                sum1 = best;\n                sum2 = best;\n                i++; j++;\n            }\n        }\n        while (i < n) sum1 += nums1[i++];\n        while (j < m) sum2 += nums2[j++];\n        return (int)(Math.max(sum1, sum2) % mod);\n    }\n}"
          }
        },
        "description": "<p>You are given two <strong>sorted</strong> arrays of distinct integers <code>nums1</code> and <code>nums2</code>.</p>\n\n<p>A <strong>valid<strong><em> </em></strong>path</strong> is defined as follows:</p>\n\n<ul>\n\t<li>Choose array <code>nums1</code> or <code>nums2</code> to traverse (from index-0).</li>\n\t<li>Traverse the current array from left to right.</li>\n\t<li>If you are reading any value that is present in <code>nums1</code> and <code>nums2</code> you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).</li>\n</ul>\n\n<p>The <strong>score</strong> is defined as the sum of unique values in a valid path.</p>\n\n<p>Return <em>the maximum score you can obtain of all possible <strong>valid paths</strong></em>. Since the answer may be too large, return it modulo <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/sample_1_1893.png\" style=\"width: 500px; height: 151px;\" />\n<pre>\n<strong>Input:</strong> nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> Valid paths:\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\nThe maximum is obtained with the path in green <strong>[2,4,6,8,10]</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n<strong>Output:</strong> 109\n<strong>Explanation:</strong> Maximum sum is obtained with the path <strong>[1,3,5,100]</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n<strong>Output:</strong> 40\n<strong>Explanation:</strong> There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path [6,7,8,9,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>nums1</code> and <code>nums2</code> are strictly increasing.</li>\n</ul>\n"
      },
      {
        "id": "two-10",
        "title": "Create Maximum Number",
        "slug": "create-maximum-number",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/create-maximum-number/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Create Maximum Number\nclass Solution {\npublic:\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<int> best;\n        int n = nums1.size(), m = nums2.size();\n        for (int i = max(0, k - m); i <= min(k, n); ++i) {\n            vector<int> sub1 = maxSubsequence(nums1, i);\n            vector<int> sub2 = maxSubsequence(nums2, k - i);\n            vector<int> candidate = merge(sub1, sub2);\n            if (best.empty() || candidate > best) best = candidate;\n        }\n        return best;\n    }\n    vector<int> maxSubsequence(vector<int>& nums, int k) {\n        vector<int> res;\n        int drop = nums.size() - k;\n        for (int num : nums) {\n            while (drop > 0 && !res.empty() && res.back() < num) {\n                res.pop_back();\n                drop--;\n            }\n            res.push_back(num);\n        }\n        res.resize(k);\n        return res;\n    }\n    vector<int> merge(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> res;\n        auto i1 = nums1.begin(), i2 = nums2.begin();\n        while (i1 != nums1.end() || i2 != nums2.end()) {\n            if (lexicographical_compare(i1, nums1.end(), i2, nums2.end())) res.push_back(*i2++);\n            else res.push_back(*i1++);\n        }\n        return res;\n    }\n};",
            "java": "// Java Solution for Create Maximum Number\nclass Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int[] best = new int[0];\n        int n = nums1.length, m = nums2.length;\n        for (int i = Math.max(0, k - m); i <= Math.min(k, n); ++i) {\n            int[] sub1 = maxSubsequence(nums1, i);\n            int[] sub2 = maxSubsequence(nums2, k - i);\n            int[] candidate = merge(sub1, sub2);\n            if (greater(candidate, 0, best, 0)) best = candidate;\n        }\n        return best;\n    }\n    private int[] maxSubsequence(int[] nums, int k) {\n        int[] res = new int[k];\n        int len = 0;\n        for (int i = 0; i < nums.length; i++) {\n            while (len > 0 && len + (nums.length - i) > k && res[len - 1] < nums[i]) {\n                len--;\n            }\n            if (len < k) res[len++] = nums[i];\n        }\n        return res;\n    }\n    private int[] merge(int[] nums1, int[] nums2) {\n        int[] res = new int[nums1.length + nums2.length];\n        int i = 0, j = 0, r = 0;\n        while (r < res.length) {\n            res[r++] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n        }\n        return res;\n    }\n    private boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++; j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n}"
          }
        },
        "description": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>\n\n<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>\n\n<p>Return an array of the <code>k</code> digits representing the answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n<strong>Output:</strong> [9,8,6,5,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5\n<strong>Output:</strong> [6,7,6,0,4]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3\n<strong>Output:</strong> [9,8,9]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= m + n</code></li>\n\t<li><code>nums1</code> and <code>nums2</code> do not have leading zeros.</li>\n</ul>\n"
      },
      {
        "id": "two-13",
        "title": "Next Palindrome Using Same Digits",
        "slug": "next-palindrome-using-same-digits",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/next-palindrome-using-same-digits/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Next Palindrome Using Same Digits\nclass Solution {\npublic:\n    string nextPalindrome(string num) {\n        int n = num.size();\n        string half = num.substr(0, n / 2);\n        if (!next_permutation(half.begin(), half.end())) return \"\";\n        string res = half;\n        if (n % 2) res += num[n / 2];\n        reverse(half.begin(), half.end());\n        res += half;\n        return res;\n    }\n};",
            "java": "// Java Solution for Next Palindrome Using Same Digits\nclass Solution {\n    public String nextPalindrome(String num) {\n        int n = num.length();\n        char[] chars = num.toCharArray();\n        char[] half = new char[n / 2];\n        System.arraycopy(chars, 0, half, 0, n / 2);\n        \n        if (!nextPermutation(half)) return \"\";\n        \n        StringBuilder sb = new StringBuilder();\n        sb.append(half);\n        if (n % 2 != 0) sb.append(chars[n / 2]);\n        sb.append(new StringBuilder(new String(half)).reverse());\n        return sb.toString();\n    }\n    private boolean nextPermutation(char[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\n        if (i < 0) return false;\n        int j = nums.length - 1;\n        while (nums[j] <= nums[i]) j--;\n        char temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;\n        for (int p = i + 1, q = nums.length - 1; p < q; p++, q--) {\n            temp = nums[p]; nums[p] = nums[q]; nums[q] = temp;\n        }\n        return true;\n    }\n}"
          }
        },
        "description": "<p>You are given a numeric string <code>num</code>, representing a very large <strong>palindrome</strong>.</p><p>Return<em> the <strong>smallest palindrome larger than </strong></em><code>num</code><em> that can be created by rearranging its digits. If no such palindrome exists, return an empty string </em><code>\"\"</code>.</p><p>A <strong>palindrome</strong> is a number that reads the same backward as forward.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> num = \"1221\"\n<strong>Output:</strong> \"2112\"\n<strong>Explanation:</strong>&nbsp;The next palindrome larger than \"1221\" is \"2112\".\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> num = \"32123\"\n<strong>Output:</strong> \"\"\n<strong>Explanation:</strong>&nbsp;No palindromes larger than \"32123\" can be made by rearranging the digits.\n</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> num = \"45544554\"\n<strong>Output:</strong> \"54455445\"\n<strong>Explanation:</strong> The next palindrome larger than \"45544554\" is \"54455445\".\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> is a <strong>palindrome</strong>.</li>\n</ul>"
      },
      {
        "id": "two-15",
        "title": "Find the Lexicographically Largest String From Box II",
        "slug": "find-the-lexicographically-largest-string-from-box",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-ii/description/",
        "patternSlug": "two-pointers",
        "theory": {
          "explanation": "This is a classic Two Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Two Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Two Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Two Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Lexicographically Largest String From Box II\nclass Solution {\npublic:\n    string stringFromBox(string box) {\n        string maxStr = \"\";\n        int n = box.length();\n        for (int i = 0; i < n; ++i) {\n             if (box[i] != '#') {\n                 string current = box.substr(i);\n                 if (current > maxStr) maxStr = current;\n             }\n        }\n        return maxStr;\n    }\n};",
            "java": "// Java Solution for Find the Lexicographically Largest String From Box II\nclass Solution {\n    public String stringFromBox(String box) {\n        String maxStr = \"\";\n        int n = box.length();\n        for (int i = 0; i < n; ++i) {\n             if (box.charAt(i) != '#') {\n                 String current = box.substring(i);\n                 if (current.compareTo(maxStr) > 0) maxStr = current;\n             }\n        }\n        return maxStr;\n    }\n}"
          }
        },
        "description": "<p>You are given a string <code>word</code>, and an integer <code>numFriends</code>.</p><p>Alice is organizing a game for her <code>numFriends</code> friends. There are multiple rounds in the game, where in each round:</p><ul><li><code>word</code> is split into <code>numFriends</code> <strong>non-empty</strong> strings, such that no previous round has had the <strong>exact</strong> same split.</li><li>All the split words are put into a box.</li></ul><p>Find the <strong>lexicographically largest</strong> string from the box after all the rounds are finished.</p><p>A string <code>a</code> is <strong>lexicographically smaller</strong> than a string <code>b</code> if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>.<br>If the first <code>min(a.length, b.length)</code> characters do not differ, then the shorter string is the lexicographically smaller one.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><div><p><strong>Input:</strong> <span>word = \"dbca\", numFriends = 2</span></p><p><strong>Output:</strong> <span>\"dbc\"</span></p><p><strong>Explanation:</strong></p><p>All possible splits are:</p><ul><li><code>\"d\"</code> and <code>\"bca\"</code>.</li><li><code>\"db\"</code> and <code>\"ca\"</code>.</li><li><code>\"dbc\"</code> and <code>\"a\"</code>.</li></ul></div><p><strong>Example 2:</strong></p><div><p><strong>Input:</strong> <span>word = \"gggg\", numFriends = 4</span></p><p><strong>Output:</strong> <span>\"g\"</span></p><p><strong>Explanation:</strong></p><p>The only possible split is: <code>\"g\"</code>, <code>\"g\"</code>, <code>\"g\"</code>, and <code>\"g\"</code>.</p></div><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= word.length &lt;= 2 * 10<sup>5</sup></code></li><li><code>word</code> consists only of lowercase English letters.</li><li><code>1 &lt;= numFriends &lt;= word.length</code></li></ul>"
      }
    ]
  },
  {
    "id": "pattern-2",
    "name": "Fast and Slow Pointers",
    "slug": "fast-and-slow-pointers",
    "icon": "ðŸ¢",
    "description": "Master the Fast and Slow Pointers pattern",
    "items": [
      {
        "id": "fsp-theory",
        "title": "Fast and Slow Pointer Theory",
        "slug": "fast-and-slow-pointer-theory",
        "difficulty": "theory",
        "isTheory": true,
        "patternSlug": "fast-and-slow-pointers",
        "lectureNotesSvg": "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/7_Day/NOTES/FINAL_2_Fast_Slow_Pointer_Theory.excalidraw.svg",
        "theory": {
          "explanation": "The Fast and Slow Pointer (Floyd's Tortoise and Hare) pattern uses two pointers moving at different speeds through a sequence. This is especially useful for detecting cycles, finding middle elements, and solving linked list problems efficiently.",
          "whenToUse": [
            "Detecting cycles in linked lists or arrays",
            "Finding the middle element of a linked list",
            "Finding the start of a cycle",
            "Problems involving cyclic sequences"
          ],
          "intuition": "Imagine two runners on a circular track - the faster one will eventually lap the slower one. This same principle helps us detect cycles and find meeting points in data structures.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty list",
            "Single node",
            "No cycle present",
            "Cycle at the head"
          ]
        },
        "solutions": {
          "code": {
            "java": "// Generic Fast and Slow Pointers Template\npublic boolean fastSlow(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}",
            "cpp": "// Generic Fast and Slow Pointers Template\nbool fastSlow(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
          }
        }
      },
      {
        "id": "fas-2",
        "title": "Linked List Cycle",
        "slug": "linked-list-cycle",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/linked-list-cycle/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if (slow == fast) return true;\n        }\n        return false;\n    }\n};",
            "java": "public class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
          }
        },
        "description": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"
      },
      {
        "id": "fas-1",
        "title": "Happy Number",
        "slug": "happy-number",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/happy-number/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int sumOfSquaresOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int dig = n % 10;\n            sum += dig * dig;\n            n /= 10;\n        }\n        return sum;\n    }\n\n    bool isHappy(int n) {\n        int slow = n;\n        int fast = n;\n        \n        while (true) {\n            slow = sumOfSquaresOfDigits(slow);\n            fast = sumOfSquaresOfDigits(sumOfSquaresOfDigits(fast));\n            \n            if (fast == 1) return true;\n            if (slow == fast) return false;\n        }\n    }\n};",
            "java": "class Solution {\n    public int sumOfSquaresOfDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int dig = n % 10;\n            sum = sum + (dig * dig);\n            n = n / 10;\n        }\n        return sum;\n    }\n\n    public boolean isHappy(int n) {\n        int slow = n;\n        int fast = n;\n        \n        while (true) {\n            slow = sumOfSquaresOfDigits(slow);\n            fast = sumOfSquaresOfDigits(sumOfSquaresOfDigits(fast));\n            \n            if (fast == 1) {\n                return true;\n            }\n            if (slow == fast) {\n                return false;\n            }\n        }\n    }\n}"
          }
        },
        "description": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"
      },
      {
        "id": "fas-3",
        "title": "Middle of the Linked List",
        "slug": "middle-of-the-linked-list",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/middle-of-the-linked-list/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};",
            "java": "class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}"
          }
        },
        "description": "<p>Given the <code>head</code> of a singly linked list, return <em>the middle node of the linked list</em>.</p>\n\n<p>If there are two middle nodes, return <strong>the second middle</strong> node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [3,4,5]\n<strong>Explanation:</strong> The middle node of the list is node 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5,6]\n<strong>Output:</strong> [4,5,6]\n<strong>Explanation:</strong> Since the list has two middle nodes with values 3 and 4, we return the second one.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"
      },
      {
        "id": "fas-9",
        "title": "Linked List Cycle II",
        "slug": "linked-list-cycle-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/linked-list-cycle-ii/description/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Linked List Cycle II\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        bool hasCycle = false;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                hasCycle = true;\n                break;\n            }\n        }\n        if (!hasCycle) return nullptr;\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};",
            "java": "// Java Solution for Linked List Cycle II\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        boolean hasCycle = false;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                hasCycle = true;\n                break;\n            }\n        }\n        if (!hasCycle) return null;\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}"
          }
        },
        "description": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"
      },
      {
        "id": "fas-10",
        "title": "Find length of Loop",
        "slug": "find-length-of-loop",
        "difficulty": "medium",
        "externalLink": "https://www.geeksforgeeks.org/problems/find-length-of-loop/1",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find length of Loop\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find length of Loop\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find length of Loop\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given the <strong>head</strong> of a singly linked list, determine the length of the cycle (loop) if one exists. A cycle occurs when a node's next pointer points to a previously visited node in the list. If no cycle is present, return 0.</p><p><strong>Examples:</strong></p><blockquote><p><strong>Input: </strong></p><p><strong>Output: </strong>3<br><strong>Explanation</strong>: There exists a loop in the linked list and the length of the loop is 3.</p><p><strong>Input: </strong></p><p><strong>Output: </strong>0<br><strong>Explanation</strong>: There is no loop present in the Linked List.</p></blockquote>"
      },
      {
        "id": "fas-5",
        "title": "Find the Duplicate Number",
        "slug": "find-the-duplicate-number",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-duplicate-number/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int slow = 0;\n        int fast = 0;\n        \n        // Detect cycle\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        \n        // Find entry point of cycle\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n};",
            "java": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0;\n        int fast = 0;\n        \n        // Detect cycle\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        \n        // Find entry point of cycle\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
            "python": "# Python Solution for Find the Duplicate Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>\n\n<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>\n\n<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and using only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3,3,3,3]\n<strong>Output:</strong> 3</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b></p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>\n\t<li>Can you solve the problem in linear runtime complexity?</li>\n</ul>\n"
      },
      {
        "id": "fas-6",
        "title": "Palindrome Linked List",
        "slug": "palindrome-linked-list",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/palindrome-linked-list/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* curr) {\n        ListNode* prev = nullptr;\n        while (curr != nullptr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    bool isPalindrome(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        // Find middle\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // Reverse second half\n        ListNode* p2 = reverseList(slow);\n        ListNode* p1 = head;\n        \n        // Compare halves\n        while (p2 != nullptr) {\n            if (p1->val != p2->val) return false;\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        return true;\n    }\n};",
            "java": "class Solution {\n    public ListNode reverseList(ListNode curr) {\n        ListNode prev = null;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public boolean isPalindrome(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Find middle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // Reverse second half\n        ListNode p2 = reverseList(slow);\n        ListNode p1 = head;\n        \n        // Compare halves\n        while (p2 != null) {\n            if (p1.val != p2.val) {\n                return false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return true;\n    }\n}",
            "python": "# Python Solution for Palindrome Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword=\"palindrome-sequence\"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,2,1]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?"
      },
      {
        "id": "fas-7",
        "title": "Maximum Twin Sum of a Linked List",
        "slug": "maximum-twin-sum-of-a-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    ListNode* reverseLL(ListNode* node) {\n        ListNode* curr = node;\n        ListNode* prev = nullptr;\n        while (curr != nullptr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    int pairSum(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        ListNode* p2 = reverseLL(slow);\n        ListNode* p1 = head;\n        \n        int maxVal = INT_MIN;\n        while (p1 != nullptr && p2 != nullptr) {\n            maxVal = max(maxVal, p1->val + p2->val);\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        return maxVal;\n    }\n};",
            "java": "class Solution {\n    public ListNode reverseLL(ListNode node) {\n        ListNode curr = node;\n        ListNode prev = null;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public int pairSum(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        // Find middle\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        ListNode p2 = reverseLL(slow);\n        ListNode p1 = head;\n        \n        int max = Integer.MIN_VALUE;\n        while (p1 != null && p2 != null) {\n            int candidate = p1.val + p2.val;\n            max = Math.max(max, candidate);\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return max;\n    }\n}",
            "python": "# Python Solution for Maximum Twin Sum of a Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>\n\n<ul>\n\t<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>\n</ul>\n\n<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>\n\n<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [5,4,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nNodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\nThere are no other nodes with twins in the linked list.\nThus, the maximum twin sum of the linked list is 6. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,2,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\nThe nodes with twins present in this linked list are:\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\nThus, the maximum twin sum of the linked list is max(7, 4) = 7. \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\" />\n<pre>\n<strong>Input:</strong> head = [1,100000]\n<strong>Output:</strong> 100001\n<strong>Explanation:</strong>\nThere is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n"
      },
      {
        "id": "fas-4",
        "title": "Circular Array Loop",
        "slug": "circular-array-loop",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/circular-array-loop/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int calcNextIdx(vector<int>& nums, int curr) {\n        int n = nums.size();\n        return ((curr + nums[curr]) % n + n) % n;\n    }\n\n    bool circularArrayLoop(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            \n            int slow = i, fast = i;\n            bool isForward = nums[i] > 0;\n            \n            while (true) {\n                slow = calcNextIdx(nums, slow);\n                if (isForward != (nums[slow] > 0)) break;\n                \n                fast = calcNextIdx(nums, fast);\n                if (isForward != (nums[fast] > 0)) break;\n                \n                fast = calcNextIdx(nums, fast);\n                if (isForward != (nums[fast] > 0)) break;\n                \n                if (slow == fast) {\n                    if (slow == calcNextIdx(nums, slow)) break;\n                    return true;\n                }\n            }\n            \n            int curr = i;\n            int val = nums[i];\n            while (nums[curr] * val > 0) {\n                int next = calcNextIdx(nums, curr);\n                nums[curr] = 0;\n                curr = next;\n            }\n        }\n        return false;\n    }\n};",
            "java": "class Solution {\n    public int calcNextIdx(int[] nums, int curr) {\n        int next = curr;\n        int seq = nums[curr];\n        int rawNext = next + seq;\n        int nextIdx = (rawNext % nums.length + nums.length) % nums.length;\n        return nextIdx;\n    }\n\n    public boolean circularArrayLoop(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            \n            int slow = i;\n            int fast = i;\n            boolean isForward = nums[i] > 0;\n            \n            while (true) {\n                slow = calcNextIdx(nums, slow);\n                if (isForward != (nums[slow] > 0)) break;\n                \n                fast = calcNextIdx(nums, fast);\n                if (isForward != (nums[fast] > 0)) break;\n                \n                fast = calcNextIdx(nums, fast);\n                if (isForward != (nums[fast] > 0)) break;\n                \n                if (slow == fast) {\n                    if (slow == calcNextIdx(nums, slow)) break;\n                    return true;\n                }\n            }\n            \n            int curr = i;\n            int val = nums[i];\n            while (nums[curr] * val > 0) {\n                int next = calcNextIdx(nums, curr);\n                nums[curr] = 0;\n                curr = next;\n            }\n        }\n        return false;\n    }\n}",
            "python": "# Python Solution for Circular Array Loop\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are playing a game involving a <strong>circular</strong> array of non-zero integers <code>nums</code>. Each <code>nums[i]</code> denotes the number of indices forward/backward you must move if you are located at index <code>i</code>:</p>\n\n<ul>\n\t<li>If <code>nums[i]</code> is positive, move <code>nums[i]</code> steps <strong>forward</strong>, and</li>\n\t<li>If <code>nums[i]</code> is negative, move <code>abs(nums[i])</code> steps <strong>backward</strong>.</li>\n</ul>\n\n<p>Since the array is <strong>circular</strong>, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.</p>\n\n<p>A <strong>cycle</strong> in the array consists of a sequence of indices <code>seq</code> of length <code>k</code> where:</p>\n\n<ul>\n\t<li>Following the movement rules above results in the repeating index sequence <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\n\t<li>Every <code>nums[seq[j]]</code> is either <strong>all positive</strong> or <strong>all negative</strong>.</li>\n\t<li><code>k &gt; 1</code></li>\n</ul>\n\n<p>Return <code>true</code><em> if there is a <strong>cycle</strong> in </em><code>nums</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img1.jpg\" style=\"width: 402px; height: 289px;\" />\n<pre>\n<strong>Input:</strong> nums = [2,-1,1,2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 2 --&gt; 3 --&gt; 0 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img2.jpg\" style=\"width: 402px; height: 390px;\" />\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,-5,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nThe only cycle is of size 1, so we return false.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img3.jpg\" style=\"width: 497px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,-1,5,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 1 --&gt; 0 --&gt; ..., and while it is of size &gt; 1, it has a node jumping forward and a node jumping backward, so <strong>it is not a cycle</strong>.\nWe can see the cycle 3 --&gt; 4 --&gt; 3 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it in <code>O(n)</code> time complexity and <code>O(1)</code> extra space complexity?</p>\n"
      },
      {
        "id": "fas-8",
        "title": "Split a Circular Linked List",
        "slug": "split-a-circular-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/split-a-circular-linked-list/description/",
        "patternSlug": "fast-and-slow-pointers",
        "theory": {
          "explanation": "This is a classic Fast and Slow Pointers problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Fast and Slow Pointers",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Fast and Slow Pointers technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Fast and Slow Pointers technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Split a Circular Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Split a Circular Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Split a Circular Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a <strong>circular linked list</strong> <code>list</code> of positive integers, your task is to split it into 2 <strong>circular linked lists</strong> so that the first one contains the <strong>first half</strong> of the nodes in <code>list</code> (exactly <code>ceil(list.length / 2)</code> nodes) in the same order they appeared in <code>list</code>, and the second one contains <strong>the rest</strong> of the nodes in <code>list</code> in the same order they appeared in <code>list</code>.</p><p>Return <em>an array answer of length 2 in which the first element is a <strong>circular linked list</strong> representing the <strong>first half</strong> and the second element is a <strong>circular linked list</strong> representing the <strong>second half</strong>.</em></p><p>A <strong>circular linked list</strong> is a normal linked list with the only difference being that the last node's next node, is the first node.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums = [1,5,7]\n<strong>Output:</strong> [[1,5],[7]]\n<strong>Explanation:</strong> The initial list has 3 nodes so the first half would be the first 2 elements since ceil(3 / 2) = 2 and the rest which is 1 node is in the second half.\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums = [2,6,1,5]\n<strong>Output:</strong> [[2,6],[1,5]]\n<strong>Explanation:</strong> The initial list has 4 nodes so the first half would be the first 2 elements since ceil(4 / 2) = 2 and the rest which is 2 nodes are in the second half.\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li>The number of nodes in <code>list</code>&nbsp;is in the range <code>[2, 10<sup>5</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>LastNode.next = FirstNode</code> where <code>LastNode</code> is the last node of the list and <code>FirstNode</code> is the first one</li>\n</ul>"
      }
    ]
  },
  {
    "id": "pattern-3",
    "name": "Sliding Window",
    "slug": "sliding-window",
    "icon": "ðŸªŸ",
    "description": "Master the Sliding Window pattern",
    "lectureNotes": [
      "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/12_Day/NOTES/FINAL_3_Sliding_Window_Theory.excalidraw.svg",
      "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/17_Day/NOTES/Revision_Dynamic_Sliding_Window.svg"
    ],
    "items": [
      {
        "id": "sw-theory",
        "title": "Sliding Window Theory",
        "slug": "sliding-window-theory",
        "difficulty": "theory",
        "isTheory": true,
        "patternSlug": "sliding-window",
        "lectureNotesSvg": "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/12_Day/NOTES/FINAL_3_Sliding_Window_Theory.excalidraw.svg",
        "theory": {
          "explanation": "The Sliding Window pattern maintains a window of elements and slides it across the data structure to solve subarray/substring problems efficiently. There are two types: Fixed Size Window and Dynamic Size Window.",
          "whenToUse": [
            "Finding maximum/minimum sum of subarrays of size k",
            "Longest substring with k distinct characters",
            "String permutation/anagram problems",
            "Subarray with given sum"
          ],
          "intuition": "Instead of recalculating everything for each position, we slide a window and only update what changes - adding new elements and removing old ones.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) to O(k)",
          "edgeCases": [
            "Window size larger than array",
            "Empty array",
            "All elements same",
            "No valid window exists"
          ]
        },
        "solutions": {
          "code": {
            "java": "// Generic Sliding Window Template\npublic int slidingWindow(int[] nums) {\n    int left = 0, right = 0, ans = 0;\n    while (right < nums.length) {\n        while (invalid()) left++;\n        ans = Math.max(ans, right - left + 1);\n        right++;\n    }\n    return ans;\n}",
            "cpp": "// Generic Sliding Window Template\npublic int slidingWindow(vector<int>& nums) {\n    int left = 0, right = 0, ans = 0;\n    while (right < nums.length) {\n        while (invalid()) left++;\n        ans = Math.max(ans, right - left + 1);\n        right++;\n    }\n    return ans;\n}"
          }
        }
      },
      {
        "id": "sli-7",
        "title": "Minimum Size Subarray Sum",
        "slug": "minimum-size-subarray-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-size-subarray-sum/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        int minLen = INT_MAX;\n        int sum = 0;\n        int i = 0;\n        \n        for (int j = 0; j < n; ++j) {\n            sum += nums[j];\n            while (sum >= target) {\n                minLen = min(minLen, j - i + 1);\n                sum -= nums[i];\n                i++;\n            }\n        }\n        return minLen == INT_MAX ? 0 : minLen;\n    }\n};",
            "java": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int size = Integer.MAX_VALUE;\n        int sum = 0;\n        int i = 0;\n        int j = 0;\n        \n        while (j < nums.length) {\n            sum += nums[j];\n            \n            while (sum >= target) {\n                size = Math.min(size, j - i + 1);\n                sum -= nums[i];\n                i++;\n            }\n            j++;\n        }\n        return size == Integer.MAX_VALUE ? 0 : size;\n    }\n}",
            "python": "# Python Solution for Minimum Size Subarray Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword=\"subarray-nonempty\"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 4, nums = [1,4,4]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>."
      },
      {
        "id": "sli-11",
        "title": "Contains Duplicate II",
        "slug": "contains-duplicate-ii",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/contains-duplicate-ii/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_set<int> set;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > k) set.erase(nums[i - k - 1]);\n            if (set.count(nums[i])) return true;\n            set.insert(nums[i]);\n        }\n        return false;\n    }\n};",
            "java": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (i > k) {\n                set.remove(nums[i - k - 1]);\n            }\n            if (set.contains(nums[i])) {\n                return true;\n            }\n            set.add(nums[i]);\n        }\n        return false;\n    }\n}",
            "python": "# Python Solution for Contains Duplicate II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"
      },
      {
        "id": "sli-8",
        "title": "Maximum Average Subarray I",
        "slug": "maximum-average-subarray-i",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/maximum-average-subarray-i/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    double findMaxAverage(vector<int>& nums, int k) {\n        double sum = 0;\n        for (int i = 0; i < k; ++i) sum += nums[i];\n        double maxSum = sum;\n        \n        for (int i = k; i < nums.size(); ++i) {\n            sum += nums[i] - nums[i - k];\n            maxSum = max(maxSum, sum);\n        }\n        return maxSum / k;\n    }\n};",
            "java": "class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        double max = sum;\n        \n        for (int i = k; i < nums.length; i++) {\n            sum += nums[i] - nums[i - k];\n            max = Math.max(max, sum);\n        }\n        return max / k;\n    }\n}",
            "python": "# Python Solution for Maximum Average Subarray I\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given an integer array <code>nums</code> consisting of <code>n</code> elements, and an integer <code>k</code>.</p>\n\n<p>Find a contiguous subarray whose <strong>length is equal to</strong> <code>k</code> that has the maximum average value and return <em>this value</em>. Any answer with a calculation error less than <code>10<sup>-5</sup></code> will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,12,-5,-6,50,3], k = 4\n<strong>Output:</strong> 12.75000\n<strong>Explanation:</strong> Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5], k = 1\n<strong>Output:</strong> 5.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"
      },
      {
        "id": "sli-6",
        "title": "Longest Substring Without Repeating Characters",
        "slug": "longest-substring-without-repeating-characters",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int maxLen = 0, i = 0, j = 0;\n        unordered_set<char> set;\n        \n        while (j < s.length()) {\n            while (set.count(s[j])) {\n                set.erase(s[i]);\n                i++;\n            }\n            set.insert(s[j]);\n            maxLen = max(maxLen, j - i + 1);\n            j++;\n        }\n        return maxLen;\n    }\n};",
            "java": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int max = 0;\n        int i = 0;\n        int j = 0;\n        Set<Character> set = new HashSet<>();\n        \n        while (j < s.length()) {\n            char c = s.charAt(j);\n            while (set.contains(c)) {\n                set.remove(s.charAt(i));\n                i++;\n            }\n            set.add(c);\n            max = Math.max(max, j - i + 1);\n            j++;\n        }\n        return max;\n    }\n}",
            "python": "# Python Solution for Longest Substring Without Repeating Characters\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword=\"substring-nonempty\"><strong>substring</strong></span> without duplicate characters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3. Note that <code>&quot;bca&quot;</code> and <code>&quot;cab&quot;</code> are also correct answers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n"
      },
      {
        "id": "sli-1",
        "title": "Repeated DNA Sequences",
        "slug": "repeated-dna-sequences",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/repeated-dna-sequences/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Repeated DNA Sequences\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Repeated DNA Sequences\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Repeated DNA Sequences\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>\n</ul>\n\n<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>\n\n<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>Output:</strong> [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAAAAAAAAAA\"\n<strong>Output:</strong> [\"AAAAAAAAAA\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>\n</ul>\n"
      },
      {
        "id": "sli-10",
        "title": "Fruit Into Baskets",
        "slug": "fruit-into-baskets",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/fruit-into-baskets/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        int maxLen = 0, i = 0;\n        unordered_map<int, int> map;\n        \n        for (int j = 0; j < fruits.size(); ++j) {\n            map[fruits[j]]++;\n            while (map.size() > 2) {\n                map[fruits[i]]--;\n                if (map[fruits[i]] == 0) map.erase(fruits[i]);\n                i++;\n            }\n            maxLen = max(maxLen, j - i + 1);\n        }\n        return maxLen;\n    }\n};",
            "java": "class Solution {\n    public int totalFruit(int[] fruits) {\n        int max = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        int i = 0;\n        int j = 0;\n        \n        while (j < fruits.length) {\n            map.put(fruits[j], map.getOrDefault(fruits[j], 0) + 1);\n            \n            while (map.size() > 2) {\n                map.put(fruits[i], map.get(fruits[i]) - 1);\n                if (map.get(fruits[i]) == 0) {\n                    map.remove(fruits[i]);\n                }\n                i++;\n            }\n            max = Math.max(max, j - i + 1);\n            j++;\n        }\n        return max;\n    }\n}",
            "python": "# Python Solution for Fruit Into Baskets\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code>fruits</code> where <code>fruits[i]</code> is the <strong>type</strong> of fruit the <code>i<sup>th</sup></code> tree produces.</p>\n\n<p>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:</p>\n\n<ul>\n\t<li>You only have <strong>two</strong> baskets, and each basket can only hold a <strong>single type</strong> of fruit. There is no limit on the amount of fruit each basket can hold.</li>\n\t<li>Starting from any tree of your choice, you must pick <strong>exactly one fruit</strong> from <strong>every</strong> tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li>\n\t<li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li>\n</ul>\n\n<p>Given the integer array <code>fruits</code>, return <em>the <strong>maximum</strong> number of fruits you can pick</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [<u>1,2,1</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from all 3 trees.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [0,<u>1,2,2</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from trees [1,2,2].\nIf we had started at the first tree, we would only pick from trees [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [1,<u>2,3,2,2</u>]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can pick from trees [2,3,2,2].\nIf we had started at the first tree, we would only pick from trees [1,2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>\n</ul>\n"
      },
      {
        "id": "sli-12",
        "title": "Frequency of the Most Frequent Element",
        "slug": "frequency-of-the-most-frequent-element",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Frequency of the Most Frequent Element\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Frequency of the Most Frequent Element\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Frequency of the Most Frequent Element\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>The <strong>frequency</strong> of an element is the number of times it occurs in an array.</p>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. In one operation, you can choose an index of <code>nums</code> and increment the element at that index by <code>1</code>.</p>\n\n<p>Return <em>the <strong>maximum possible frequency</strong> of an element after performing <strong>at most</strong> </em><code>k</code><em> operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4], k = 5\n<strong>Output:</strong> 3<strong>\nExplanation:</strong> Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,4,8,13], k = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,9,6], k = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"
      },
      {
        "id": "sli-4",
        "title": "Longest Repeating Character Replacement",
        "slug": "longest-repeating-character-replacement",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-repeating-character-replacement/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int maxLen = 0, i = 0, maxC = 0;\n        vector<int> counts(26, 0);\n        \n        for (int j = 0; j < s.length(); ++j) {\n            maxC = max(maxC, ++counts[s[j] - 'A']);\n            \n            if ((j - i + 1) - maxC > k) {\n                counts[s[i] - 'A']--;\n                i++;\n            }\n            maxLen = max(maxLen, j - i + 1);\n        }\n        return maxLen;\n    }\n};",
            "java": "class Solution {\n    public int characterReplacement(String s, int k) {\n        int max = 0;\n        int i = 0;\n        int j = 0;\n        int maxC = 0;\n        int[] counts = new int[26];\n        \n        while (j < s.length()) {\n            char c = s.charAt(j);\n            counts[c - 'A']++;\n            maxC = Math.max(maxC, counts[c - 'A']);\n            \n            if ((j - i + 1) - maxC > k) {\n                char d = s.charAt(i);\n                counts[d - 'A']--;\n                i++;\n            }\n            max = Math.max(max, j - i + 1);\n            j++;\n        }\n        return max;\n    }\n}",
            "python": "# Python Solution for Longest Repeating Character Replacement\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>\n\n<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABAB&quot;, k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;AABABBA&quot;, k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.\nThe substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only uppercase English letters.</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n"
      },
      {
        "id": "sli-2",
        "title": "Sliding Window Maximum",
        "slug": "sliding-window-maximum",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/sliding-window-maximum/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sliding Window Maximum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sliding Window Maximum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sliding Window Maximum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n"
      },
      {
        "id": "sli-3",
        "title": "Minimum Window Subsequence",
        "slug": "minimum-window-subsequence",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-window-subsequence/description/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Window Subsequence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Window Subsequence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Window Subsequence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given strings <code>s1</code> and <code>s2</code>, return <em>the minimum contiguous&nbsp;substring part of </em><code>s1</code><em>, so that </em><code>s2</code><em> is a subsequence of the part</em>.</p><p>If there is no such window in <code>s1</code> that covers all characters in <code>s2</code>, return the empty string <code>\"\"</code>. If there are multiple such minimum-length windows, return the one with the <strong>left-most starting index</strong>.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = \"abcdebdde\", s2 = \"bde\"\n<strong>Output:</strong> \"bcde\"\n<strong>Explanation:</strong> \n\"bcde\" is the answer because it occurs before \"bdde\" which has the same length.\n\"deb\" is not a smaller window because the elements of s2 in the window must occur in order.\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> s1 = \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\", s2 = \"u\"\n<strong>Output:</strong> \"\"\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= s1.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= s2.length &lt;= 100</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>"
      },
      {
        "id": "sli-5",
        "title": "Minimum Window Substring",
        "slug": "minimum-window-substring",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-window-substring/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Window Substring\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Window Substring\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Window Substring\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n"
      },
      {
        "id": "sli-9",
        "title": "Diet Plan Performance",
        "slug": "diet-plan-performance",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/diet-plan-performance/description/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Diet Plan Performance\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Diet Plan Performance\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Diet Plan Performance\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>A dieter consumes&nbsp;<code>calories[i]</code>&nbsp;calories on the <code>i</code>-th day.&nbsp;</p><p>Given an integer <code>k</code>, for <strong>every</strong> consecutive sequence of <code>k</code> days (<code>calories[i], calories[i+1], ..., calories[i+k-1]</code>&nbsp;for all <code>0 &lt;= i &lt;= n-k</code>), they look at <em>T</em>, the total calories consumed during that sequence of <code>k</code> days (<code>calories[i] + calories[i+1] + ... + calories[i+k-1]</code>):</p><ul>\n\t<li>If <code>T &lt; lower</code>, they performed poorly on their diet and lose 1 point;&nbsp;</li>\n\t<li>If <code>T &gt; upper</code>, they performed well on their diet and gain 1 point;</li>\n\t<li>Otherwise, they performed normally and there is no change in points.</li>\n</ul><p>Initially, the dieter has zero points. Return the total number of points the dieter has after dieting for <code>calories.length</code>&nbsp;days.</p><p>Note that the total points can be negative.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3\n<strong>Output:</strong> 0\n<strong>Explanation</strong>: Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories[0] and calories[1] are less than lower so 2 points are lost.\ncalories[3] and calories[4] are greater than upper so 2 points are gained.\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> calories = [3,2], k = 2, lower = 0, upper = 1\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: Since k = 2, we consider subarrays of length 2.\ncalories[0] + calories[1] &gt; upper so 1 point is gained.\n</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> calories = [6,5,0,0], k = 2, lower = 1, upper = 5\n<strong>Output:</strong> 0\n<strong>Explanation</strong>:\ncalories[0] + calories[1] &gt; upper so 1 point is gained.\nlower &lt;= calories[1] + calories[2] &lt;= upper so no change in points.\ncalories[2] + calories[3] &lt; lower so 1 point is lost.\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= k &lt;= calories.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= calories[i] &lt;= 20000</code></li>\n\t<li><code>0 &lt;= lower &lt;= upper</code></li>\n</ul>"
      },
      {
        "id": "sli-13",
        "title": "Subarrays with K Different Integers",
        "slug": "subarrays-with-k-different-integers",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/subarrays-with-k-different-integers/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Subarrays with K Different Integers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Subarrays with K Different Integers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Subarrays with K Different Integers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>good subarrays</strong> of </em><code>nums</code>.</p>\n\n<p>A <strong>good array</strong> is an array where the number of different integers in that array is exactly <code>k</code>.</p>\n\n<ul>\n\t<li>For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.</li>\n</ul>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,1,2,3], k = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,1,3,4], k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>\n</ul>"
      },
      {
        "id": "sli-14",
        "title": "Count Subarrays With Score Less Than K",
        "slug": "count-subarrays-with-score-less-than-k",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/count-subarrays-with-score-less-than-k/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Subarrays With Score Less Than K\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Subarrays With Score Less Than K\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Subarrays With Score Less Than K\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>The <strong>score</strong> of an array is defined as the <strong>product</strong> of its sum and its length.</p>\n\n<ul>\n\t<li>For example, the score of <code>[1, 2, 3, 4, 5]</code> is <code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code>.</li>\n</ul>\n\n<p>Given a positive integer array <code>nums</code> and an integer <code>k</code>, return <em>the <strong>number of non-empty subarrays</strong> of</em> <code>nums</code> <em>whose score is <strong>strictly less</strong> than</em> <code>k</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [2,1,4,3,5], k = 10\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nThe 6 subarrays having scores less than 10 are:\n- [2] with score 2 * 1 = 2.\n- [1] with score 1 * 1 = 1.\n- [4] with score 4 * 1 = 4.\n- [3] with score 3 * 1 = 3. \n- [5] with score 5 * 1 = 5.\n- [2,1] with score (2 + 1) * 2 = 6.\nNote that subarrays such as [1,4] and [4,3,5] are not considered because their scores are 10 and 36 respectively, while we need scores strictly less than 10.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,1,1], k = 5\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nEvery subarray except [1,1,1] has a score less than 5.\n[1,1,1] has a score (1 + 1 + 1) * 3 = 9, which is greater than 5.\nThus, there are 5 subarrays having scores less than 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>\n</ul>"
      },
      {
        "id": "sli-15",
        "title": "Count Substrings With K-Frequency Characters II",
        "slug": "count-substrings-with-k-frequency-characters-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-substrings-with-k-frequency-characters-ii/description/",
        "patternSlug": "sliding-window",
        "theory": {
          "explanation": "This is a classic Sliding Window problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sliding Window",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sliding Window technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sliding Window technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Substrings With K-Frequency Characters II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Substrings With K-Frequency Characters II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Substrings With K-Frequency Characters II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a string <code>s</code> and an integer <code>k</code>, return the total number of <span>substrings</span> of <code>s</code> where <strong>at least one</strong> character appears <strong>at least</strong> <code>k</code> times.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> <span>s = \"abacb\", k = 2</span></p><p><strong>Output:</strong> <span>4</span></p><p><strong>Explanation:</strong></p><p>The valid substrings are:</p><ul>\n\t<li>\"<code>aba\"</code> (character <code>'a'</code> appears 2 times).</li>\n\t<li><code>\"abac\"</code> (character <code>'a'</code> appears 2 times).</li>\n\t<li><code>\"abacb\"</code> (character <code>'a'</code> appears 2 times).</li>\n\t<li><code>\"bacb\"</code> (character <code>'b'</code> appears 2 times).</li>\n</ul><p><strong>Example 2:</strong></p><p><strong>Input:</strong> <span>s = \"abcde\", k = 1</span></p><p><strong>Output:</strong> <span>15</span></p><p><strong>Explanation:</strong></p><p>All substrings are valid because every character appears at least once.</p><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n</ul>"
      }
    ]
  },
  {
    "id": "pattern-4",
    "name": "Intervals",
    "slug": "intervals",
    "icon": "ðŸ“…",
    "description": "Master the Intervals pattern",
    "lectureNotes": [
      "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/19_Day/NOTES/FINAL_4_Intervals_Theory.excalidraw.svg",
      "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/20_Day/NOTES/FINAL_4_Intervals_Theory_Part_2.excalidraw.svg"
    ],
    "items": [
      {
        "id": "int-theory-1",
        "title": "Intervals Theory Part 1",
        "slug": "intervals-theory-part-1",
        "difficulty": "theory",
        "isTheory": true,
        "patternSlug": "intervals",
        "lectureNotesSvg": "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/19_Day/NOTES/FINAL_4_Intervals_Theory.excalidraw.svg",
        "theory": {
          "explanation": "Interval problems involve ranges with start and end points. Understanding interval relationships (overlap, contain, disjoint) is key to solving these problems. Common operations include merging, inserting, and finding intersections.",
          "whenToUse": [
            "Merging overlapping intervals",
            "Finding intersections between interval lists",
            "Scheduling problems (meeting rooms)",
            "Calendar booking systems"
          ],
          "intuition": "Two intervals overlap if one starts before the other ends. Sort intervals by start time, then process them sequentially.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "edgeCases": [
            "Empty intervals list",
            "Single interval",
            "All intervals overlap",
            "No intervals overlap"
          ]
        }
      },
      {
        "id": "int-9",
        "title": "Meeting Rooms II",
        "slug": "meeting-rooms-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/meeting-rooms-ii/description/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Meeting Rooms II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Meeting Rooms II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Meeting Rooms II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of conference rooms required</em>.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> intervals = [[0,30],[5,10],[15,20]]\n<strong>Output:</strong> 2\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> intervals = [[7,10],[2,4]]\n<strong>Output:</strong> 1\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;=&nbsp;intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>"
      },
      {
        "id": "int-1",
        "title": "Merge Intervals",
        "slug": "merge-intervals",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/merge-intervals/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return {};\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> res;\n        res.push_back(intervals[0]);\n        \n        for (int i = 1; i < intervals.size(); ++i) {\n            if (intervals[i][0] <= res.back()[1]) {\n                res.back()[1] = max(res.back()[1], intervals[i][1]);\n            } else {\n                res.push_back(intervals[i]);\n            }\n        }\n        return res;\n    }\n};",
            "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        List<int[]> list = new ArrayList<>();\n        list.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] prev = list.get(list.size() - 1);\n            int[] curr = intervals[i];\n            \n            if (curr[0] <= prev[1]) {\n                prev[0] = Math.min(prev[0], curr[0]);\n                prev[1] = Math.max(prev[1], curr[1]);\n            } else {\n                list.add(intervals[i]);\n            }\n        }\n        \n        return list.toArray(new int[list.size()][]);\n    }\n}",
            "python": "# Python Solution for Merge Intervals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,4],[4,5]]\n<strong>Output:</strong> [[1,5]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[4,7],[1,4]]\n<strong>Output:</strong> [[1,7]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,7] are considered overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>"
      },
      {
        "id": "int-3",
        "title": "Interval List Intersections",
        "slug": "interval-list-intersections",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/interval-list-intersections/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {\n        vector<vector<int>> res;\n        int i = 0, j = 0;\n        \n        while (i < firstList.size() && j < secondList.size()) {\n            int s1 = firstList[i][0], e1 = firstList[i][1];\n            int s2 = secondList[j][0], e2 = secondList[j][1];\n            \n            if (e1 >= s2 && e2 >= s1) {\n                res.push_back({max(s1, s2), min(e1, e2)});\n            }\n            \n            if (e1 < e2) i++;\n            else j++;\n        }\n        return res;\n    }\n};",
            "java": "class Solution {\n    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n        List<int[]> res = new ArrayList<>();\n        int i = 0;\n        int j = 0;\n        \n        while (i < firstList.length && j < secondList.length) {\n            int s1 = firstList[i][0];\n            int e1 = firstList[i][1];\n            int s2 = secondList[j][0];\n            int e2 = secondList[j][1];\n            \n            if (e1 >= s2 && e2 >= s1) {\n                res.add(new int[]{\n                    Math.max(s1, s2),\n                    Math.min(e1, e2)\n                });\n            }\n            \n            if (e1 < e2) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        return res.toArray(new int[res.size()][]);\n    }\n}",
            "python": "# Python Solution for Interval List Intersections\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given two lists of closed intervals, <code>firstList</code> and <code>secondList</code>, where <code>firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> and <code>secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]</code>. Each list of intervals is pairwise <strong>disjoint</strong> and in <strong>sorted order</strong>.</p>\n\n<p>Return <em>the intersection of these two interval lists</em>.</p>\n\n<p>A <strong>closed interval</strong> <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>.</p>\n\n<p>The <strong>intersection</strong> of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of <code>[1, 3]</code> and <code>[2, 4]</code> is <code>[2, 3]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/30/interval1.png\" style=\"width: 700px; height: 194px;\">\n<pre><strong>Input:</strong> firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n<strong>Output:</strong> [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> firstList = [[1,3],[5,9]], secondList = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= firstList.length, secondList.length &lt;= 1000</code></li>\n\t<li><code>firstList.length + secondList.length &gt;= 1</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>end<sub>i</sub> &lt; start<sub>i+1</sub></code></li>\n\t<li><code>0 &lt;= start<sub>j</sub> &lt; end<sub>j</sub> &lt;= 10<sup>9</sup> </code></li>\n\t<li><code>end<sub>j</sub> &lt; start<sub>j+1</sub></code></li>\n</ul>"
      },
      {
        "id": "int-5",
        "title": "Count Days Without Meetings",
        "slug": "count-days-without-meetings",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-days-without-meetings/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Days Without Meetings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Days Without Meetings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Days Without Meetings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given a positive integer <code>days</code> representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array <code>meetings</code> of size <code>n</code> where, <code>meetings[i] = [start_i, end_i]</code> represents the starting and ending days of meeting <code>i</code> (inclusive).</p>\n\n<p>Return the count of days when the employee is available for work but no meetings are scheduled.</p>\n\n<p><strong>Note: </strong>The meetings may overlap.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 10, meetings = [[5,7],[1,3],[9,10]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no meeting scheduled on the 4<sup>th</sup> and 8<sup>th</sup> days.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 5, meetings = [[2,4],[1,3]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no meeting scheduled on the 5<sup>th </sup>day.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 6, meetings = [[1,6]]</span></p>\n\n<p><strong>Output:</strong> 0</p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Meetings are scheduled for all working days.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 2</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= meetings[i][0] &lt;= meetings[i][1] &lt;= days</font></code></li>\n</ul>"
      },
      {
        "id": "int-2",
        "title": "Insert Interval",
        "slug": "insert-interval",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/insert-interval/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> res;\n        int i = 0;\n        \n        while (i < intervals.size() && intervals[i][1] < newInterval[0]) {\n            res.push_back(intervals[i++]);\n        }\n        \n        while (i < intervals.size() && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        res.push_back(newInterval);\n        \n        while (i < intervals.size()) {\n            res.push_back(intervals[i++]);\n        }\n        return res;\n    }\n};",
            "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        int i = 0;\n        List<int[]> res = new ArrayList<>();\n        \n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            res.add(intervals[i]);\n            i++;\n        }\n        \n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        res.add(newInterval);\n        \n        while (i < intervals.length) {\n            res.add(intervals[i]);\n            i++;\n        }\n        \n        return res.toArray(new int[res.size()][]);\n    }\n}",
            "python": "# Python Solution for Insert Interval\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don't need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>"
      },
      {
        "id": "int-6",
        "title": "Remove Covered Intervals",
        "slug": "remove-covered-intervals",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/remove-covered-intervals/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n        });\n        \n        int count = 0;\n        int maxEnd = 0;\n        for (const auto& interval : intervals) {\n            if (interval[1] > maxEnd) {\n                count++;\n                maxEnd = interval[1];\n            }\n        }\n        return count;\n    }\n};",
            "java": "class Solution {\n    public int removeCoveredIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> {\n            int val = Integer.compare(a[0], b[0]);\n            return val == 0 ? Integer.compare(b[1], a[1]) : val;\n        });\n        \n        int count = 0;\n        int maxEnd = 0;\n        \n        for (int[] interval : intervals) {\n            if (interval[1] > maxEnd) {\n                count++;\n                maxEnd = interval[1];\n            }\n        }\n        return count;\n    }\n}",
            "python": "# Python Solution for Remove Covered Intervals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given an array <code>intervals</code> where <code>intervals[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> represent the interval <code>[l<sub>i</sub>, r<sub>i</sub>)</code>, remove all intervals that are covered by another interval in the list.</p>\n\n<p>The interval <code>[a, b)</code> is covered by the interval <code>[c, d)</code> if and only if <code>c &lt;= a</code> and <code>b &lt;= d</code>.</p>\n\n<p>Return <em>the number of remaining intervals</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,4],[3,6],[2,8]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Interval [3,6] is covered by [2,8], therefore it is removed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> intervals = [[1,4],[2,3]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 1000</code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= l<sub>i</sub> &lt; r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li>All the given intervals are <strong>unique</strong>.</li>\n</ul>"
      },
      {
        "id": "int-7",
        "title": "Car Pooling",
        "slug": "car-pooling",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/car-pooling/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        vector<int> stops(1001, 0);\n        for (auto& t : trips) {\n            stops[t[1]] += t[0];\n            stops[t[2]] -= t[0];\n        }\n        int cur = 0;\n        for (int i : stops) {\n            cur += i;\n            if (cur > capacity) return false;\n        }\n        return true;\n    }\n};",
            "java": "class Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        int[] buckets = new int[1001];\n        \n        for (int[] trip : trips) {\n            int numPassengers = trip[0];\n            int start = trip[1];\n            int end = trip[2];\n            buckets[start] += numPassengers;\n            buckets[end] -= numPassengers;\n        }\n        \n        int passengers = 0;\n        for (int bucket : buckets) {\n            passengers += bucket;\n            if (passengers > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
            "python": "# Python Solution for Car Pooling\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>There is a car with <code>capacity</code> empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).</p>\n\n<p>You are given the integer <code>capacity</code> and an array <code>trips</code> where <code>trips[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> trip has <code>numPassengers<sub>i</sub></code> passengers and the locations to pick them up and drop them off are <code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> respectively. The locations are given as the number of kilometers due east from the car's initial location.</p>\n\n<p>Return <code>true</code><em> if it is possible to pick up and drop off all passengers for all the given trips, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input:</strong> trips = [[2,1,5],[3,3,7]], capacity = 4\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre><strong>Input:</strong> trips = [[2,1,5],[3,3,7]], capacity = 5\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= trips.length &lt;= 1000</code></li>\n\t<li><code>trips[i].length == 3</code></li>\n\t<li><code>1 &lt;= numPassengers<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li>\n</ul>"
      },
      {
        "id": "int-8",
        "title": "Data Stream as Disjoint Intervals",
        "slug": "data-stream-as-disjoint-intervals",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/data-stream-as-disjoint-intervals/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Data Stream as Disjoint Intervals\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Data Stream as Disjoint Intervals\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Data Stream as Disjoint Intervals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input</strong>\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>"
      },
      {
        "id": "int-theory-2",
        "title": "Intervals Theory Part 2",
        "slug": "intervals-theory-part-2",
        "difficulty": "theory",
        "isTheory": true,
        "patternSlug": "intervals",
        "lectureNotesSvg": "https://raw.githubusercontent.com/team-codebug/babua-dsa-patterns-course/main/20_Day/NOTES/FINAL_4_Intervals_Theory_Part_2.excalidraw.svg",
        "theory": {
          "explanation": "Advanced interval techniques include Line Sweep algorithm and using TreeMap for efficient interval management. Line Sweep processes events at interval boundaries to track active intervals.",
          "whenToUse": [
            "Finding maximum overlapping intervals",
            "My Calendar problems",
            "Meeting Rooms II (minimum rooms needed)",
            "Event scheduling with conflicts"
          ],
          "intuition": "Instead of checking all pairs of intervals, process start and end points as events. Use a sweep line moving left to right, tracking how many intervals are active.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "edgeCases": [
            "Back-to-back intervals",
            "Fully contained intervals",
            "Same start time, different end times",
            "Many overlapping intervals"
          ]
        }
      },
      {
        "id": "int-4",
        "title": "Employee Free Time",
        "slug": "employee-free-time",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/employee-free-time/description/",
        "patternSlug": "intervals",
        "theory": {
          "explanation": "This is a classic Intervals problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Intervals",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Intervals technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Intervals technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Employee Free Time\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Employee Free Time\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Employee Free Time\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        },
        "description": "<p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p><p>Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p><p>Return the list of finite intervals representing <b>common, positive-length free time</b> for <i>all</i> employees, also in sorted order.</p><p>(Even though we are representing <code>Intervals</code> in the form <code>[x, y]</code>, the objects inside are <code>Intervals</code>, not lists or arrays. For example, <code>schedule[0][0].start = 1</code>, <code>schedule[0][0].end = 2</code>, and <code>schedule[0][0][0]</code> is not defined).&nbsp; Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\n<strong>Output:</strong> [[3,4]]\n<strong>Explanation:</strong> There are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\n</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\n<strong>Output:</strong> [[5,6],[7,9]]\n</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>\n\t<li><code>1 &lt;= schedule.length , schedule[i].length &lt;= 50</code></li>\n\t<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code></li>\n</ul>"
      }
    ]
  },
  {
    "id": "pattern-5",
    "name": "Linked List In-Place Manipulati",
    "slug": "linked-list-in-place-manipulati",
    "icon": "ðŸ”—",
    "description": "Master the Linked List In-Place Manipulati pattern",
    "items": [
      {
        "id": "lin-1",
        "title": "Reverse Linked List",
        "slug": "reverse-linked-list",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/reverse-linked-list/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-2",
        "title": "Reverse Nodes in k-Group",
        "slug": "reverse-nodes-in-k-group",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Nodes in k-Group\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Nodes in k-Group\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Nodes in k-Group\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-3",
        "title": "Reverse Linked List II",
        "slug": "reverse-linked-list-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reverse-linked-list-ii/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Linked List II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Linked List II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Linked List II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-4",
        "title": "Reorder List",
        "slug": "reorder-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reorder-list/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reorder List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reorder List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reorder List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-5",
        "title": "Swapping Nodes in a Linked List",
        "slug": "swapping-nodes-in-a-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Swapping Nodes in a Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Swapping Nodes in a Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Swapping Nodes in a Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-6",
        "title": "Reverse Nodes in Even Length Groups",
        "slug": "reverse-nodes-in-even-length-groups",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reverse-nodes-in-even-length-groups/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Nodes in Even Length Groups\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Nodes in Even Length Groups\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Nodes in Even Length Groups\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-7",
        "title": "Remove Duplicates from Sorted List",
        "slug": "remove-duplicates-from-sorted-list",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Remove Duplicates from Sorted List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Remove Duplicates from Sorted List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Remove Duplicates from Sorted List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-8",
        "title": "Remove Linked List Elements",
        "slug": "remove-linked-list-elements",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/remove-linked-list-elements/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Remove Linked List Elements\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Remove Linked List Elements\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Remove Linked List Elements\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-9",
        "title": "Split Linked List in Parts",
        "slug": "split-linked-list-in-parts",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/split-linked-list-in-parts/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Split Linked List in Parts\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Split Linked List in Parts\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Split Linked List in Parts\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-10",
        "title": "Delete N Nodes After M Nodes of a Linked List",
        "slug": "delete-n-nodes-after-m-nodes-of-a-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/description/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Delete N Nodes After M Nodes of a Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Delete N Nodes After M Nodes of a Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Delete N Nodes After M Nodes of a Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-11",
        "title": "Insert into a Sorted Circular Linked List",
        "slug": "insert-into-a-sorted-circular-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/description/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Insert into a Sorted Circular Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Insert into a Sorted Circular Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Insert into a Sorted Circular Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-12",
        "title": "Odd Even Linked List",
        "slug": "odd-even-linked-list",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/odd-even-linked-list/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Odd Even Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Odd Even Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Odd Even Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "lin-13",
        "title": "Swap Nodes in Pairs",
        "slug": "swap-nodes-in-pairs",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/swap-nodes-in-pairs/",
        "patternSlug": "linked-list-in-place-manipulati",
        "theory": {
          "explanation": "This is a classic Linked List In-Place Manipulati problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Linked List In-Place Manipulati",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Linked List In-Place Manipulati technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Linked List In-Place Manipulati technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Swap Nodes in Pairs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Swap Nodes in Pairs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Swap Nodes in Pairs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-6",
    "name": "Heaps",
    "slug": "heaps",
    "icon": "â›°ï¸",
    "description": "Master the Heaps pattern",
    "items": [
      {
        "id": "hea-1",
        "title": "IPO",
        "slug": "ipo",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/ipo/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for IPO\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for IPO\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for IPO\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-2",
        "title": "Find Median from Data Stream",
        "slug": "find-median-from-data-stream",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-median-from-data-stream/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Median from Data Stream\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Median from Data Stream\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Median from Data Stream\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-3",
        "title": "Sliding Window Median",
        "slug": "sliding-window-median",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/sliding-window-median/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sliding Window Median\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sliding Window Median\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sliding Window Median\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-4",
        "title": "Task Scheduler",
        "slug": "task-scheduler",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/task-scheduler/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Task Scheduler\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Task Scheduler\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Task Scheduler\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-5",
        "title": "Meeting Rooms III",
        "slug": "meeting-rooms-iii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/meeting-rooms-iii/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Meeting Rooms III\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Meeting Rooms III\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Meeting Rooms III\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-6",
        "title": "Largest Number After Digit Swaps by Parity",
        "slug": "largest-number-after-digit-swaps-by-parity",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Largest Number After Digit Swaps by Parity\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Largest Number After Digit Swaps by Parity\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Largest Number After Digit Swaps by Parity\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-7",
        "title": "Find Right Interval",
        "slug": "find-right-interval",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-right-interval/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Right Interval\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Right Interval\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Right Interval\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-8",
        "title": "Minimum Cost to Connect Sticks",
        "slug": "minimum-cost-to-connect-sticks",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-cost-to-connect-sticks/description/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Cost to Connect Sticks\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Cost to Connect Sticks\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Cost to Connect Sticks\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-9",
        "title": "Longest Happy String",
        "slug": "longest-happy-string",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-happy-string/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Happy String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Happy String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Happy String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-10",
        "title": "Maximum Average Pass Ratio",
        "slug": "maximum-average-pass-ratio",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-average-pass-ratio/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Average Pass Ratio\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Average Pass Ratio\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Average Pass Ratio\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-11",
        "title": "The Number of the Smallest Unoccupied Chair",
        "slug": "the-number-of-the-smallest-unoccupied-chair",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for The Number of the Smallest Unoccupied Chair\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for The Number of the Smallest Unoccupied Chair\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for The Number of the Smallest Unoccupied Chair\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "hea-12",
        "title": "Construct Target Array With Multiple Sums",
        "slug": "construct-target-array-with-multiple-sums",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/construct-target-array-with-multiple-sums/",
        "patternSlug": "heaps",
        "theory": {
          "explanation": "This is a classic Heaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Heaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Heaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Heaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Construct Target Array With Multiple Sums\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Construct Target Array With Multiple Sums\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Construct Target Array With Multiple Sums\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-7",
    "name": "K-way merge",
    "slug": "k-way-merge",
    "icon": "ðŸ”€",
    "description": "Master the K-way merge pattern",
    "items": [
      {
        "id": "kw-1",
        "title": "Merge Sorted Array",
        "slug": "merge-sorted-array",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/merge-sorted-array/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        \n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};",
            "java": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i];\n                i = i - 1;\n            } else {\n                nums1[k] = nums2[j];\n                j = j - 1;\n            }\n            k = k - 1;\n        }\n\n        while (j >= 0) {\n            nums1[k] = nums2[j];\n            k = k - 1;\n            j = j - 1;\n        }\n    }\n}",
            "python": "# Python Solution for Merge Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-2",
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "slug": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/description/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Kth Smallest Sum of a Matrix With Sorted Rows\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Kth Smallest Sum of a Matrix With Sorted Rows\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Kth Smallest Sum of a Matrix With Sorted Rows\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-3",
        "title": "Find K Pairs with Smallest Sums",
        "slug": "find-k-pairs-with-smallest-sums",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find K Pairs with Smallest Sums\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find K Pairs with Smallest Sums\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find K Pairs with Smallest Sums\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-4",
        "title": "Merge k Sorted Lists",
        "slug": "merge-k-sorted-lists",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/merge-k-sorted-lists/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Merge k Sorted Lists\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Merge k Sorted Lists\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Merge k Sorted Lists\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-5",
        "title": "Kth Smallest Element in a Sorted Matrix",
        "slug": "kth-smallest-element-in-a-sorted-matrix",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Kth Smallest Element in a Sorted Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Kth Smallest Element in a Sorted Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Kth Smallest Element in a Sorted Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-6",
        "title": "K-th Smallest Prime Fraction",
        "slug": "k-th-smallest-prime-fraction",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/k-th-smallest-prime-fraction/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for K-th Smallest Prime Fraction\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for K-th Smallest Prime Fraction\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for K-th Smallest Prime Fraction\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "kw-7",
        "title": "Super Ugly Number",
        "slug": "super-ugly-number",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/super-ugly-number/",
        "patternSlug": "k-way-merge",
        "theory": {
          "explanation": "This is a classic K-way merge problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to K-way merge",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how K-way merge technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using K-way merge technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Super Ugly Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Super Ugly Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Super Ugly Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-8",
    "name": "Top K Elements",
    "slug": "top-k-elements",
    "icon": "ðŸ†",
    "description": "Master the Top K Elements pattern",
    "items": [
      {
        "id": "top-1",
        "title": "Kth Largest Element in a Stream",
        "slug": "kth-largest-element-in-a-stream",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Kth Largest Element in a Stream\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Kth Largest Element in a Stream\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Kth Largest Element in a Stream\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-2",
        "title": "Reorganize String",
        "slug": "reorganize-string",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reorganize-string/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reorganize String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reorganize String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reorganize String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-3",
        "title": "K Closest Points to Origin",
        "slug": "k-closest-points-to-origin",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/k-closest-points-to-origin/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for K Closest Points to Origin\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for K Closest Points to Origin\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for K Closest Points to Origin\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-4",
        "title": "Top K Frequent Elements",
        "slug": "top-k-frequent-elements",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/top-k-frequent-elements/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Top K Frequent Elements\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Top K Frequent Elements\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Top K Frequent Elements\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-5",
        "title": "Kth Largest Element in an Array",
        "slug": "kth-largest-element-in-an-array",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Kth Largest Element in an Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Kth Largest Element in an Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Kth Largest Element in an Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-6",
        "title": "Third Maximum Number",
        "slug": "third-maximum-number",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/third-maximum-number/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Third Maximum Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Third Maximum Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Third Maximum Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-7",
        "title": "Find Subsequence of Length K With the Largest Sum",
        "slug": "find-subsequence-of-length-k-with-the-largest-sum",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Subsequence of Length K With the Largest Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Subsequence of Length K With the Largest Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Subsequence of Length K With the Largest Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-8",
        "title": "Minimum Cost to Hire K Workers",
        "slug": "minimum-cost-to-hire-k-workers",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Cost to Hire K Workers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Cost to Hire K Workers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Cost to Hire K Workers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-9",
        "title": "Maximal Score After Applying K Operations",
        "slug": "maximal-score-after-applying-k-operations",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximal-score-after-applying-k-operations/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximal Score After Applying K Operations\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximal Score After Applying K Operations\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximal Score After Applying K Operations\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-10",
        "title": "Find the Kth Largest Integer in the Array",
        "slug": "find-the-kth-largest-integer-in-the-array",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Kth Largest Integer in the Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Kth Largest Integer in the Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Kth Largest Integer in the Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-11",
        "title": "Maximum Performance of a Team",
        "slug": "maximum-performance-of-a-team",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/maximum-performance-of-a-team/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Performance of a Team\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Performance of a Team\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Performance of a Team\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-12",
        "title": "Smallest Range Covering Elements from K Lists",
        "slug": "smallest-range-covering-elements-from-k-lists",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Smallest Range Covering Elements from K Lists\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Smallest Range Covering Elements from K Lists\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Smallest Range Covering Elements from K Lists\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-13",
        "title": "K Empty Slots",
        "slug": "k-empty-slots",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/k-empty-slots/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for K Empty Slots\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for K Empty Slots\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for K Empty Slots\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-14",
        "title": "Choose K Elements With Maximum Sum",
        "slug": "choose-k-elements-with-maximum-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/choose-k-elements-with-maximum-sum/description/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Choose K Elements With Maximum Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Choose K Elements With Maximum Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Choose K Elements With Maximum Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-15",
        "title": "Maximum Product After K Increments",
        "slug": "maximum-product-after-k-increments",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-product-after-k-increments/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Product After K Increments\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Product After K Increments\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Product After K Increments\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-16",
        "title": "Find the K-Sum of an Array",
        "slug": "find-the-k-sum-of-an-array",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-the-k-sum-of-an-array/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the K-Sum of an Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the K-Sum of an Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the K-Sum of an Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-17",
        "title": "Least Number of Unique Integers after K Removals",
        "slug": "least-number-of-unique-integers-after-k-removals",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Least Number of Unique Integers after K Removals\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Least Number of Unique Integers after K Removals\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Least Number of Unique Integers after K Removals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-18",
        "title": "Final Array State After K Multiplication Operations I",
        "slug": "final-array-state-after-k-multiplication-operation",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Final Array State After K Multiplication Operations I\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Final Array State After K Multiplication Operations I\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Final Array State After K Multiplication Operations I\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-19",
        "title": "Final Array State After K Multiplication Operations II",
        "slug": "final-array-state-after-k-multiplication-operation",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-ii/description/",
        "patternSlug": "top-k-elements",
        "theory": {
          "explanation": "This is a classic Top K Elements problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Top K Elements",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Top K Elements technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Top K Elements technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Final Array State After K Multiplication Operations II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Final Array State After K Multiplication Operations II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Final Array State After K Multiplication Operations II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-9",
    "name": "Binary Search",
    "slug": "binary-search",
    "icon": "ðŸ”",
    "description": "Master the Binary Search pattern",
    "items": [
      {
        "id": "bin-1",
        "title": "Binary Search",
        "slug": "binary-search",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/binary-search/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Search\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Search\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Search\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-2",
        "title": "Search in Rotated Sorted Array",
        "slug": "search-in-rotated-sorted-array",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/search-in-rotated-sorted-array/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Search in Rotated Sorted Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Search in Rotated Sorted Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Search in Rotated Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-3",
        "title": "First Bad Version",
        "slug": "first-bad-version",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/first-bad-version/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for First Bad Version\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for First Bad Version\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for First Bad Version\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-4",
        "title": "Random Pick with Weight",
        "slug": "random-pick-with-weight",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/random-pick-with-weight/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Random Pick with Weight\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Random Pick with Weight\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Random Pick with Weight\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-5",
        "title": "Find K Closest Elements",
        "slug": "find-k-closest-elements",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-k-closest-elements/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find K Closest Elements\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find K Closest Elements\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find K Closest Elements\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-6",
        "title": "Single Element in a Sorted Array",
        "slug": "single-element-in-a-sorted-array",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Single Element in a Sorted Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Single Element in a Sorted Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Single Element in a Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-7",
        "title": "Maximum Value at a Given Index in a Bounded Array",
        "slug": "maximum-value-at-a-given-index-in-a-bounded-array",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Value at a Given Index in a Bounded Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Value at a Given Index in a Bounded Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Value at a Given Index in a Bounded Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-8",
        "title": "The K Weakest Rows in a Matrix",
        "slug": "the-k-weakest-rows-in-a-matrix",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for The K Weakest Rows in a Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for The K Weakest Rows in a Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for The K Weakest Rows in a Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-9",
        "title": "Split Array Largest Sum",
        "slug": "split-array-largest-sum",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/split-array-largest-sum/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Split Array Largest Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Split Array Largest Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Split Array Largest Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-10",
        "title": "Find Minimum in Rotated Sorted Array II",
        "slug": "find-minimum-in-rotated-sorted-array-ii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Minimum in Rotated Sorted Array II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Minimum in Rotated Sorted Array II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Minimum in Rotated Sorted Array II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-11",
        "title": "Maximum Running Time of N Computers",
        "slug": "maximum-running-time-of-n-computers",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/maximum-running-time-of-n-computers/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Running Time of N Computers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Running Time of N Computers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Running Time of N Computers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-12",
        "title": "Minimize Max Distance to Gas Station",
        "slug": "minimize-max-distance-to-gas-station",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimize-max-distance-to-gas-station/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimize Max Distance to Gas Station\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimize Max Distance to Gas Station\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimize Max Distance to Gas Station\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-13",
        "title": "Divide Chocolate",
        "slug": "divide-chocolate",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/divide-chocolate/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Divide Chocolate\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Divide Chocolate\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Divide Chocolate\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-14",
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "slug": "partition-array-into-two-arrays-to-minimize-sum-di",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Partition Array Into Two Arrays to Minimize Sum Difference\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Partition Array Into Two Arrays to Minimize Sum Difference\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Partition Array Into Two Arrays to Minimize Sum Difference\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-15",
        "title": "Number of Flowers in Full Bloom",
        "slug": "number-of-flowers-in-full-bloom",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-flowers-in-full-bloom/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Flowers in Full Bloom\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Flowers in Full Bloom\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Flowers in Full Bloom\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-16",
        "title": "Koko Eating Bananas",
        "slug": "koko-eating-bananas",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/koko-eating-bananas/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Koko Eating Bananas\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Koko Eating Bananas\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Koko Eating Bananas\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bin-17",
        "title": "Search in Rotated Sorted Array II",
        "slug": "search-in-rotated-sorted-array-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/",
        "patternSlug": "binary-search",
        "theory": {
          "explanation": "This is a classic Binary Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Binary Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Binary Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Binary Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Search in Rotated Sorted Array II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Search in Rotated Sorted Array II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Search in Rotated Sorted Array II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-10",
    "name": "Subsets",
    "slug": "subsets",
    "icon": "ðŸ§©",
    "description": "Master the Subsets pattern",
    "items": [
      {
        "id": "sub-1",
        "title": "Subsets",
        "slug": "subsets",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/subsets/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Subsets\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Subsets\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Subsets\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-2",
        "title": "Permutations",
        "slug": "permutations",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/permutations/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Permutations\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Permutations\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Permutations\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-3",
        "title": "Letter Combinations of a Phone Number",
        "slug": "letter-combinations-of-a-phone-number",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Letter Combinations of a Phone Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Letter Combinations of a Phone Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Letter Combinations of a Phone Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-4",
        "title": "Generate Parentheses",
        "slug": "generate-parentheses",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/generate-parentheses/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Generate Parentheses\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Generate Parentheses\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Generate Parentheses\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-5",
        "title": "Letter Case Permutation",
        "slug": "letter-case-permutation",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/letter-case-permutation/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Letter Case Permutation\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Letter Case Permutation\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Letter Case Permutation\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-6",
        "title": "Letter Tile Possibilities",
        "slug": "letter-tile-possibilities",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/letter-tile-possibilities/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Letter Tile Possibilities\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Letter Tile Possibilities\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Letter Tile Possibilities\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sub-7",
        "title": "Partition to K Equal Sum Subsets",
        "slug": "partition-to-k-equal-sum-subsets",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-k-sum-of-an-array/",
        "patternSlug": "subsets",
        "theory": {
          "explanation": "This is a classic Subsets problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Subsets",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Subsets technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Subsets technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Partition to K Equal Sum Subsets\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Partition to K Equal Sum Subsets\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Partition to K Equal Sum Subsets\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-11",
    "name": "Greedy Programming",
    "slug": "greedy-programming",
    "icon": "ðŸ¤‘",
    "description": "Master the Greedy Programming pattern",
    "items": [
      {
        "id": "gre-1",
        "title": "Maximum Swap",
        "slug": "maximum-swap",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-swap/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Swap\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Swap\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Swap\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-2",
        "title": "Can Place Flowers",
        "slug": "can-place-flowers",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/can-place-flowers/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Can Place Flowers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Can Place Flowers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Can Place Flowers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-3",
        "title": "Largest Odd Number in String",
        "slug": "largest-odd-number-in-string",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/largest-odd-number-in-string/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Largest Odd Number in String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Largest Odd Number in String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Largest Odd Number in String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-4",
        "title": "Candy",
        "slug": "candy",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/candy/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Candy\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Candy\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Candy\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-5",
        "title": "Minimum Replacements to Sort the Array",
        "slug": "minimum-replacements-to-sort-the-array",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-replacements-to-sort-the-array/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Replacements to Sort the Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Replacements to Sort the Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Replacements to Sort the Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-6",
        "title": "Jump Game II",
        "slug": "jump-game-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/jump-game-ii/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Jump Game II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Jump Game II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Jump Game II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-7",
        "title": "Best Time to Buy and Sell Stock",
        "slug": "best-time-to-buy-and-sell-stock",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Best Time to Buy and Sell Stock\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Best Time to Buy and Sell Stock\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Best Time to Buy and Sell Stock\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-8",
        "title": "Jump Game",
        "slug": "jump-game",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/jump-game/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Jump Game\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Jump Game\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Jump Game\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-9",
        "title": "Boats to Save People",
        "slug": "boats-to-save-people",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/boats-to-save-people/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Boats to Save People\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Boats to Save People\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Boats to Save People\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-10",
        "title": "Gas Station",
        "slug": "gas-station",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/gas-station/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Gas Station\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Gas Station\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Gas Station\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-11",
        "title": "Two City Scheduling",
        "slug": "two-city-scheduling",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/two-city-scheduling/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Two City Scheduling\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Two City Scheduling\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Two City Scheduling\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-12",
        "title": "Minimum Number of Refueling Stops",
        "slug": "minimum-number-of-refueling-stops",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-number-of-refueling-stops/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Number of Refueling Stops\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Number of Refueling Stops\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Number of Refueling Stops\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gre-13",
        "title": "Best Time to Buy and Sell Stock II",
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/",
        "patternSlug": "greedy-programming",
        "theory": {
          "explanation": "This is a classic Greedy Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Greedy Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Greedy Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Greedy Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Best Time to Buy and Sell Stock II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Best Time to Buy and Sell Stock II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Best Time to Buy and Sell Stock II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-12",
    "name": "Backtracking",
    "slug": "backtracking",
    "icon": "â†©ï¸",
    "description": "Master the Backtracking pattern",
    "items": [
      {
        "id": "bac-1",
        "title": "N-Queens II",
        "slug": "n-queens-ii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/n-queens-ii/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for N-Queens II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for N-Queens II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for N-Queens II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-2",
        "title": "Word Search",
        "slug": "word-search",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/word-search/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Search\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Search\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Search\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-3",
        "title": "House Robber III",
        "slug": "house-robber-iii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/house-robber-iii/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for House Robber III\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for House Robber III\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for House Robber III\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-4",
        "title": "Restore IP Addresses",
        "slug": "restore-ip-addresses",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/restore-ip-addresses/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Restore IP Addresses\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Restore IP Addresses\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Restore IP Addresses\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-5",
        "title": "Flood Fill",
        "slug": "flood-fill",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/flood-fill/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Flood Fill\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Flood Fill\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Flood Fill\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-6",
        "title": "Minimum Moves to Spread Stones Over Grid",
        "slug": "minimum-moves-to-spread-stones-over-grid",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-moves-to-spread-stones-over-grid/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Moves to Spread Stones Over Grid\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Moves to Spread Stones Over Grid\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Moves to Spread Stones Over Grid\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-7",
        "title": "Binary Tree Paths",
        "slug": "binary-tree-paths",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/binary-tree-paths/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Paths\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Paths\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Paths\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-8",
        "title": "Binary Watch",
        "slug": "binary-watch",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/binary-watch/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Watch\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Watch\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Watch\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-9",
        "title": "Optimal Account Balancing",
        "slug": "optimal-account-balancing",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/optimal-account-balancing/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Optimal Account Balancing\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Optimal Account Balancing\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Optimal Account Balancing\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-10",
        "title": "Split a String Into the Max Number of Unique Substrings",
        "slug": "split-a-string-into-the-max-number-of-unique-subst",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Split a String Into the Max Number of Unique Substrings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Split a String Into the Max Number of Unique Substrings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Split a String Into the Max Number of Unique Substrings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-11",
        "title": "All Paths From Source to Target",
        "slug": "all-paths-from-source-to-target",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/all-paths-from-source-to-target/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for All Paths From Source to Target\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for All Paths From Source to Target\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for All Paths From Source to Target\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-12",
        "title": "Remove Invalid Parentheses",
        "slug": "remove-invalid-parentheses",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/remove-invalid-parentheses/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Remove Invalid Parentheses\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Remove Invalid Parentheses\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Remove Invalid Parentheses\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-13",
        "title": "N-Queens",
        "slug": "n-queens",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/n-queens/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for N-Queens\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for N-Queens\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for N-Queens\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-14",
        "title": "Unique Paths III",
        "slug": "unique-paths-iii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/unique-paths-iii/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Unique Paths III\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Unique Paths III\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Unique Paths III\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-15",
        "title": "Combinations",
        "slug": "combinations",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/combinations/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Combinations\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Combinations\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Combinations\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-16",
        "title": "Sudoku Solver",
        "slug": "sudoku-solver",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/sudoku-solver/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sudoku Solver\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sudoku Solver\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sudoku Solver\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bac-17",
        "title": "Matchsticks to Square",
        "slug": "matchsticks-to-square",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/matchsticks-to-square/",
        "patternSlug": "backtracking",
        "theory": {
          "explanation": "This is a classic Backtracking problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Backtracking",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Backtracking technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Backtracking technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Matchsticks to Square\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Matchsticks to Square\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Matchsticks to Square\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-13",
    "name": "Dynamic Programming",
    "slug": "dynamic-programming",
    "icon": "ðŸ“Š",
    "description": "Master the Dynamic Programming pattern",
    "items": [
      {
        "id": "dyn-1",
        "title": "Partition Equal Subset Sum",
        "slug": "partition-equal-subset-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Partition Equal Subset Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Partition Equal Subset Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Partition Equal Subset Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-2",
        "title": "Coin Change",
        "slug": "coin-change",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/coin-change/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Coin Change\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Coin Change\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Coin Change\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-3",
        "title": "N-th Tribonacci Number",
        "slug": "n-th-tribonacci-number",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/n-th-tribonacci-number/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for N-th Tribonacci Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for N-th Tribonacci Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for N-th Tribonacci Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-4",
        "title": "Partition Equal Subset Sum",
        "slug": "partition-equal-subset-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Partition Equal Subset Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Partition Equal Subset Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Partition Equal Subset Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-5",
        "title": "Counting Bits",
        "slug": "counting-bits",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/counting-bits/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Counting Bits\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Counting Bits\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Counting Bits\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-6",
        "title": "01 Matrix",
        "slug": "01-matrix",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/01-matrix/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for 01 Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for 01 Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for 01 Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-7",
        "title": "House Robber II",
        "slug": "house-robber-ii",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/house-robber-ii/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for House Robber II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for House Robber II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for House Robber II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-8",
        "title": "Maximum Product Subarray",
        "slug": "maximum-product-subarray",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-product-subarray/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Product Subarray\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Product Subarray\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Product Subarray\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-9",
        "title": "Combination Sum",
        "slug": "combination-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/combination-sum/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Combination Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Combination Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Combination Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-10",
        "title": "Word Break",
        "slug": "word-break",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/word-break/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Break\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Break\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Break\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-11",
        "title": "Palindromic Substrings",
        "slug": "palindromic-substrings",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/palindromic-substrings/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Palindromic Substrings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Palindromic Substrings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Palindromic Substrings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-12",
        "title": "Longest Common Subsequence",
        "slug": "longest-common-subsequence",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-common-subsequence/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Common Subsequence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Common Subsequence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Common Subsequence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-13",
        "title": "Word Break II",
        "slug": "word-break-ii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/word-break-ii/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Break II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Break II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Break II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-14",
        "title": "Decode Ways",
        "slug": "decode-ways",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/decode-ways/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Decode Ways\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Decode Ways\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Decode Ways\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-15",
        "title": "Count the Number of Good Subsequences",
        "slug": "count-the-number-of-good-subsequences",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-unique-good-subsequences/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count the Number of Good Subsequences\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count the Number of Good Subsequences\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count the Number of Good Subsequences\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-16",
        "title": "Binary Tree Cameras",
        "slug": "binary-tree-cameras",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/binary-tree-cameras/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Cameras\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Cameras\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Cameras\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-17",
        "title": "Number of Ways to Form Target String Given a Dictionary",
        "slug": "number-of-ways-to-form-target-string-given-a-dicti",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Ways to Form Target String Given a Dictionary\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Ways to Form Target String Given a Dictionary\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Ways to Form Target String Given a Dictionary\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-18",
        "title": "Pascalâ€™s Triangle",
        "slug": "pascals-triangle",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/pascals-triangle/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Pascalâ€™s Triangle\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Pascalâ€™s Triangle\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Pascalâ€™s Triangle\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-19",
        "title": "Triangle",
        "slug": "triangle",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/triangle/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Triangle\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Triangle\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Triangle\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "dyn-20",
        "title": "Climbing Stairs",
        "slug": "climbing-stairs",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/climbing-stairs/",
        "patternSlug": "dynamic-programming",
        "theory": {
          "explanation": "This is a classic Dynamic Programming problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Dynamic Programming",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Dynamic Programming technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Dynamic Programming technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Climbing Stairs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Climbing Stairs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Climbing Stairs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-14",
    "name": "Cyclic Sort",
    "slug": "cyclic-sort",
    "icon": "ðŸ”„",
    "description": "Master the Cyclic Sort pattern",
    "items": [
      {
        "id": "cyc-1",
        "title": "Cyclic Sort",
        "slug": "cyclic-sort-pattern-no-direct-problem",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/missing-number/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Cyclic Sort\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Cyclic Sort\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Cyclic Sort\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cyc-2",
        "title": "Missing Number",
        "slug": "missing-number-268",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/missing-number/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Missing Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Missing Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Missing Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cyc-3",
        "title": "First Missing Positive",
        "slug": "first-missing-positive-41",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/first-missing-positive/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for First Missing Positive\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for First Missing Positive\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for First Missing Positive\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cyc-4",
        "title": "Find the Corrupt Pair",
        "slug": "find-the-corrupt-pair-subset-of-645-set-mismatch",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/set-mismatch/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Corrupt Pair\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Corrupt Pair\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Corrupt Pair\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cyc-5",
        "title": "Sort Array By Parity II",
        "slug": "sort-array-by-parity-ii-922",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/sort-array-by-parity-ii/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sort Array By Parity II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sort Array By Parity II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sort Array By Parity II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cyc-6",
        "title": "Find the First K Missing Positive Numbers",
        "slug": "find-the-first-k-missing-positive-numbers-similar-",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
        "patternSlug": "cyclic-sort",
        "theory": {
          "explanation": "This is a classic Cyclic Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Cyclic Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Cyclic Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Cyclic Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the First K Missing Positive Numbers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the First K Missing Positive Numbers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the First K Missing Positive Numbers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-15",
    "name": "Topological Sort",
    "slug": "topological-sort",
    "icon": "ðŸ“ˆ",
    "description": "Master the Topological Sort pattern",
    "items": [
      {
        "id": "top-1",
        "title": "Compilation Order",
        "slug": "compilation-order-similar-to-210-course-schedule-i",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/course-schedule-ii/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Compilation Order\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Compilation Order\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Compilation Order\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-2",
        "title": "Alien Dictionary",
        "slug": "alien-dictionary-269",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/alien-dictionary/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Alien Dictionary\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Alien Dictionary\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Alien Dictionary\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-3",
        "title": "Verifying an Alien Dictionary",
        "slug": "verifying-an-alien-dictionary-953",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/verifying-an-alien-dictionary/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Verifying an Alien Dictionary\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Verifying an Alien Dictionary\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Verifying an Alien Dictionary\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-4",
        "title": "Course Schedule II",
        "slug": "course-schedule-ii-210",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/course-schedule-ii/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Course Schedule II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Course Schedule II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Course Schedule II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-5",
        "title": "Course Schedule",
        "slug": "course-schedule-207",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/course-schedule/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Course Schedule\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Course Schedule\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Course Schedule\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-6",
        "title": "Build a Matrix with Conditions",
        "slug": "build-a-matrix-with-conditions-2392",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/build-a-matrix-with-conditions/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Build a Matrix with Conditions\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Build a Matrix with Conditions\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Build a Matrix with Conditions\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-7",
        "title": "Longest Path With Different Adjacent Characters",
        "slug": "longest-path-with-different-adjacent-characters-22",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/longest-path-with-different-adjacent-characters/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Path With Different Adjacent Characters\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Path With Different Adjacent Characters\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Path With Different Adjacent Characters\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-8",
        "title": "Parallel Courses III",
        "slug": "parallel-courses-iii-2050",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/parallel-courses-iii/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Parallel Courses III\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Parallel Courses III\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Parallel Courses III\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "top-9",
        "title": "Find All Possible Recipes from Given Supplies",
        "slug": "find-all-possible-recipes-from-given-supplies-2115",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/",
        "patternSlug": "topological-sort",
        "theory": {
          "explanation": "This is a classic Topological Sort problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Topological Sort",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Topological Sort technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Topological Sort technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find All Possible Recipes from Given Supplies\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find All Possible Recipes from Given Supplies\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find All Possible Recipes from Given Supplies\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-16",
    "name": "Sort and Search",
    "slug": "sort-and-search",
    "icon": "ðŸ”Ž",
    "description": "Master the Sort and Search pattern",
    "items": [
      {
        "id": "sor-1",
        "title": "Find the Distance Value Between Two Arrays",
        "slug": "find-the-distance-value-between-two-arrays-1385",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-the-distance-value-between-two-arrays/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Distance Value Between Two Arrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Distance Value Between Two Arrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Distance Value Between Two Arrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-2",
        "title": "Longest Subsequence With Limited Sum",
        "slug": "longest-subsequence-with-limited-sum-2389",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/longest-subsequence-with-limited-sum/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Subsequence With Limited Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Subsequence With Limited Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Subsequence With Limited Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-3",
        "title": "Find Target Indices After Sorting Array",
        "slug": "find-target-indices-after-sorting-array-2089",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-target-indices-after-sorting-array/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Target Indices After Sorting Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Target Indices After Sorting Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Target Indices After Sorting Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-4",
        "title": "Count Pairs in Two Arrays",
        "slug": "count-pairs-in-two-arrays-1537",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/count-pairs-in-two-arrays/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Pairs in Two Arrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Pairs in Two Arrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Pairs in Two Arrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-5",
        "title": "Valid Triangle Number",
        "slug": "valid-triangle-number-611",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/valid-triangle-number/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Valid Triangle Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Valid Triangle Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Valid Triangle Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-6",
        "title": "Minimum Operations to Make All Array Elements Equal",
        "slug": "minimum-operations-to-make-all-array-elements-equa",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-operations-to-make-all-array-elements-equal/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Operations to Make All Array Elements Equal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Operations to Make All Array Elements Equal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Operations to Make All Array Elements Equal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-7",
        "title": "Sum of Mutated Array Closest to Target",
        "slug": "sum-of-mutated-array-closest-to-target-1300",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sum of Mutated Array Closest to Target\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sum of Mutated Array Closest to Target\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sum of Mutated Array Closest to Target\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-8",
        "title": "Range Sum of Sorted Subarray Sums",
        "slug": "range-sum-of-sorted-subarray-sums-1508",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum of Sorted Subarray Sums\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum of Sorted Subarray Sums\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum of Sorted Subarray Sums\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-9",
        "title": "Magnetic Force Between Two Balls",
        "slug": "magnetic-force-between-two-balls-1552",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/magnetic-force-between-two-balls/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Magnetic Force Between Two Balls\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Magnetic Force Between Two Balls\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Magnetic Force Between Two Balls\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-10",
        "title": "Find K-th Smallest Pair Distance",
        "slug": "find-k-th-smallest-pair-distance-719",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-k-th-smallest-pair-distance/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find K-th Smallest Pair Distance\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find K-th Smallest Pair Distance\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find K-th Smallest Pair Distance\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-11",
        "title": "Minimum Space Wasted from Packaging",
        "slug": "minimum-space-wasted-from-packaging-1889",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-space-wasted-from-packaging/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Space Wasted from Packaging\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Space Wasted from Packaging\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Space Wasted from Packaging\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-12",
        "title": "Russian Doll Envelopes",
        "slug": "russian-doll-envelopes-354",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/russian-doll-envelopes/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Russian Doll Envelopes\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Russian Doll Envelopes\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Russian Doll Envelopes\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-13",
        "title": "Put Marbles in Bags",
        "slug": "put-marbles-in-bags-2551",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/put-marbles-in-bags/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Put Marbles in Bags\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Put Marbles in Bags\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Put Marbles in Bags\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-14",
        "title": "H-Index",
        "slug": "h-index-274",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/h-index/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for H-Index\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for H-Index\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for H-Index\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-15",
        "title": "Two Sum Less Than K",
        "slug": "two-sum-less-than-k-1099",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/two-sum-less-than-k/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Two Sum Less Than K\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Two Sum Less Than K\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Two Sum Less Than K\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sor-16",
        "title": "Maximum Number of Integers to Choose from a Range I",
        "slug": "maximum-number-of-integers-to-choose-from-a-range-",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/",
        "patternSlug": "sort-and-search",
        "theory": {
          "explanation": "This is a classic Sort and Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Sort and Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Sort and Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Sort and Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Number of Integers to Choose from a Range I\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Number of Integers to Choose from a Range I\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Number of Integers to Choose from a Range I\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-17",
    "name": "Matrices",
    "slug": "matrices",
    "icon": "ðŸ”²",
    "description": "Master the Matrices pattern",
    "items": [
      {
        "id": "mat-1",
        "title": "Set Matrix Zeroes",
        "slug": "set-matrix-zeroes-73",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/set-matrix-zeroes/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Set Matrix Zeroes\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Set Matrix Zeroes\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Set Matrix Zeroes\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-2",
        "title": "Rotate Image",
        "slug": "rotate-image-48",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/rotate-image/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Rotate Image\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Rotate Image\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Rotate Image\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-3",
        "title": "Spiral Matrix",
        "slug": "spiral-matrix-54",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/spiral-matrix/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Spiral Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Spiral Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Spiral Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-4",
        "title": "Where Will the Ball Fall",
        "slug": "where-will-the-ball-fall-1706",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/where-will-the-ball-fall/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Where Will the Ball Fall\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Where Will the Ball Fall\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Where Will the Ball Fall\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-5",
        "title": "Transpose Matrix",
        "slug": "transpose-matrix-867",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/transpose-matrix/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Transpose Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Transpose Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Transpose Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-6",
        "title": "Count Negative Numbers in a Sorted Matrix",
        "slug": "count-negative-numbers-in-a-sorted-matrix-1351",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Negative Numbers in a Sorted Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Negative Numbers in a Sorted Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Negative Numbers in a Sorted Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-7",
        "title": "Minimum Time Takes to Reach Destination Without Drowning",
        "slug": "minimum-time-takes-to-reach-destination-without-dr",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-the-safest-path-in-a-grid/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Time Takes to Reach Destination Without Drowning\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Time Takes to Reach Destination Without Drowning\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Time Takes to Reach Destination Without Drowning\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-8",
        "title": "Smallest Rectangle Enclosing Black Pixels",
        "slug": "smallest-rectangle-enclosing-black-pixels-302",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Smallest Rectangle Enclosing Black Pixels\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Smallest Rectangle Enclosing Black Pixels\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Smallest Rectangle Enclosing Black Pixels\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-9",
        "title": "Island Perimeter",
        "slug": "island-perimeter-463",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/island-perimeter/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Island Perimeter\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Island Perimeter\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Island Perimeter\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-10",
        "title": "Convert 1D Array Into 2D Array",
        "slug": "convert-1d-array-into-2d-array-2022",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/convert-1d-array-into-2d-array/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Convert 1D Array Into 2D Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Convert 1D Array Into 2D Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Convert 1D Array Into 2D Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-11",
        "title": "Spiral Matrix II",
        "slug": "spiral-matrix-ii-59",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/spiral-matrix-ii/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Spiral Matrix II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Spiral Matrix II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Spiral Matrix II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-12",
        "title": "Flip Columns For Maximum Number of Equal Rows",
        "slug": "flip-columns-for-maximum-number-of-equal-rows-1072",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Flip Columns For Maximum Number of Equal Rows\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Flip Columns For Maximum Number of Equal Rows\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Flip Columns For Maximum Number of Equal Rows\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-13",
        "title": "Number of Spaces Cleaning Robot Cleaned",
        "slug": "number-of-spaces-cleaning-robot-cleaned-2061",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-spaces-cleaning-robot-cleaned/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Spaces Cleaning Robot Cleaned\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Spaces Cleaning Robot Cleaned\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Spaces Cleaning Robot Cleaned\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-14",
        "title": "Minimize Maximum Value in a Grid",
        "slug": "minimize-maximum-value-in-a-grid-2537-closest-rela",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-operations-to-make-array-equal-ii/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimize Maximum Value in a Grid\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimize Maximum Value in a Grid\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimize Maximum Value in a Grid\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-15",
        "title": "Kth Smallest Number in Multiplication Table",
        "slug": "kth-smallest-number-in-multiplication-table-668",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Kth Smallest Number in Multiplication Table\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Kth Smallest Number in Multiplication Table\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Kth Smallest Number in Multiplication Table\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-16",
        "title": "Swim in Rising Water",
        "slug": "swim-in-rising-water-778",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/swim-in-rising-water/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Swim in Rising Water\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Swim in Rising Water\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Swim in Rising Water\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-17",
        "title": "Best Meeting Point",
        "slug": "best-meeting-point-296",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/best-meeting-point/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Best Meeting Point\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Best Meeting Point\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Best Meeting Point\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-18",
        "title": "Game of Life",
        "slug": "game-of-life-289",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/game-of-life/",
        "patternSlug": "matrices",
        "theory": {
          "explanation": "This is a classic Matrices problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Matrices",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Matrices technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Matrices technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Game of Life\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Game of Life\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Game of Life\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-18",
    "name": "Stacks",
    "slug": "stacks",
    "icon": "ðŸ“š",
    "description": "Master the Stacks pattern",
    "items": [
      {
        "id": "sta-1",
        "title": "Basic Calculator",
        "slug": "basic-calculator-224",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/basic-calculator/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Basic Calculator\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Basic Calculator\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Basic Calculator\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-2",
        "title": "Remove All Adjacent Duplicates In String",
        "slug": "remove-all-adjacent-duplicates-in-string-1047",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Remove All Adjacent Duplicates In String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Remove All Adjacent Duplicates In String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Remove All Adjacent Duplicates In String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-3",
        "title": "Minimum Remove to Make Valid Parentheses",
        "slug": "minimum-remove-to-make-valid-parentheses-1249",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Remove to Make Valid Parentheses\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Remove to Make Valid Parentheses\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Remove to Make Valid Parentheses\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-4",
        "title": "Exclusive Time of Functions",
        "slug": "exclusive-time-of-functions-636",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/exclusive-time-of-functions/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Exclusive Time of Functions\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Exclusive Time of Functions\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Exclusive Time of Functions\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-5",
        "title": "Flatten Nested List Iterator",
        "slug": "flatten-nested-list-iterator-341",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/flatten-nested-list-iterator/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Flatten Nested List Iterator\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Flatten Nested List Iterator\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Flatten Nested List Iterator\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-6",
        "title": "Implement Queue Using Stacks",
        "slug": "implement-queue-using-stacks-232",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/implement-queue-using-stacks/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Implement Queue Using Stacks\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Implement Queue Using Stacks\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Implement Queue Using Stacks\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-7",
        "title": "Daily Temperatures",
        "slug": "daily-temperatures-739",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/daily-temperatures/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Daily Temperatures\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Daily Temperatures\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Daily Temperatures\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-8",
        "title": "Decode String",
        "slug": "decode-string-394",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/decode-string/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Decode String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Decode String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Decode String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-9",
        "title": "Minimum String Length After Removing Substrings",
        "slug": "minimum-string-length-after-removing-substrings-26",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/minimum-string-length-after-removing-substrings/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum String Length After Removing Substrings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum String Length After Removing Substrings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum String Length After Removing Substrings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-10",
        "title": "Number of Valid Subarrays",
        "slug": "number-of-valid-subarrays-1063",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-valid-subarrays/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Valid Subarrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Valid Subarrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Valid Subarrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-11",
        "title": "Number of Visible People in a Queue",
        "slug": "number-of-visible-people-in-a-queue-1944",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-visible-people-in-a-queue/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Visible People in a Queue\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Visible People in a Queue\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Visible People in a Queue\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-12",
        "title": "Parsing a Boolean Expression",
        "slug": "parsing-a-boolean-expression-1106",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/parsing-a-boolean-expression/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Parsing a Boolean Expression\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Parsing a Boolean Expression\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Parsing a Boolean Expression\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-13",
        "title": "Remove Duplicate Letters",
        "slug": "remove-duplicate-letters-316",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/remove-duplicate-letters/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Remove Duplicate Letters\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Remove Duplicate Letters\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Remove Duplicate Letters\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "sta-14",
        "title": "Valid Parentheses",
        "slug": "valid-parentheses-20",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/valid-parentheses/",
        "patternSlug": "stacks",
        "theory": {
          "explanation": "This is a classic Stacks problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Stacks",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Stacks technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Stacks technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Valid Parentheses\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Valid Parentheses\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Valid Parentheses\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-19",
    "name": "Graphs",
    "slug": "graphs",
    "icon": "ðŸ•¸ï¸",
    "description": "Master the Graphs pattern",
    "items": [
      {
        "id": "gra-1",
        "title": "Network Delay Time",
        "slug": "network-delay-time-743",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/network-delay-time/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Network Delay Time\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Network Delay Time\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Network Delay Time\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-2",
        "title": "Paths in Maze That Lead to Same Room",
        "slug": "paths-in-maze-that-lead-to-same-room-1971",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-if-path-exists-in-graph/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Paths in Maze That Lead to Same Room\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Paths in Maze That Lead to Same Room\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Paths in Maze That Lead to Same Room\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-3",
        "title": "Clone Graph",
        "slug": "clone-graph-133",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/clone-graph/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Clone Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Clone Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Clone Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-4",
        "title": "Graph Valid Tree",
        "slug": "graph-valid-tree-261",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/graph-valid-tree/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Graph Valid Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Graph Valid Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Graph Valid Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-5",
        "title": "Bus Routes",
        "slug": "bus-routes-815",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/bus-routes/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Bus Routes\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Bus Routes\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Bus Routes\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-6",
        "title": "Reconstruct Itinerary",
        "slug": "reconstruct-itinerary-332",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/reconstruct-itinerary/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reconstruct Itinerary\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reconstruct Itinerary\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reconstruct Itinerary\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-7",
        "title": "Find the Town Judge",
        "slug": "find-the-town-judge-997",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-the-town-judge/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Town Judge\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Town Judge\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Town Judge\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-8",
        "title": "Find Center of Star Graph",
        "slug": "find-center-of-star-graph-1791",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-center-of-star-graph/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Center of Star Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Center of Star Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Center of Star Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-9",
        "title": "Lucky Numbers in a Matrix",
        "slug": "lucky-numbers-in-a-matrix-1380",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/lucky-numbers-in-a-matrix/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Lucky Numbers in a Matrix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Lucky Numbers in a Matrix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Lucky Numbers in a Matrix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-10",
        "title": "Path with Maximum Probability",
        "slug": "path-with-maximum-probability-1514",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/path-with-maximum-probability/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Path with Maximum Probability\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Path with Maximum Probability\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Path with Maximum Probability\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-11",
        "title": "Tree Diameter",
        "slug": "tree-diameter-1245",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/tree-diameter/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Tree Diameter\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Tree Diameter\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Tree Diameter\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-12",
        "title": "Reorder Routes to Make All Paths Lead to the City Zero",
        "slug": "reorder-routes-to-make-all-paths-lead-to-the-city-",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reorder Routes to Make All Paths Lead to the City Zero\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reorder Routes to Make All Paths Lead to the City Zero\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reorder Routes to Make All Paths Lead to the City Zero\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-13",
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Cost to Make at Least One Valid Path in a Grid\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Cost to Make at Least One Valid Path in a Grid\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Cost to Make at Least One Valid Path in a Grid\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-14",
        "title": "Longest Cycle in a Graph",
        "slug": "longest-cycle-in-a-graph-2360",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/longest-cycle-in-a-graph/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Cycle in a Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Cycle in a Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Cycle in a Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "gra-15",
        "title": "Shortest Cycle in a Graph",
        "slug": "shortest-cycle-in-a-graph-2608",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/shortest-cycle-in-a-graph/",
        "patternSlug": "graphs",
        "theory": {
          "explanation": "This is a classic Graphs problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Graphs",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Graphs technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Graphs technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Shortest Cycle in a Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Shortest Cycle in a Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Shortest Cycle in a Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-20",
    "name": "Tree Depth-First Search",
    "slug": "tree-depth-first-search",
    "icon": "ðŸŒ²",
    "description": "Master the Tree Depth-First Search pattern",
    "items": [
      {
        "id": "tre-1",
        "title": "Flatten Binary Tree to Linked List",
        "slug": "flatten-binary-tree-to-linked-list-114",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Flatten Binary Tree to Linked List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Flatten Binary Tree to Linked List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Flatten Binary Tree to Linked List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-2",
        "title": "Diameter of Binary Tree",
        "slug": "diameter-of-binary-tree-543",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/diameter-of-binary-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Diameter of Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Diameter of Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Diameter of Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-3",
        "title": "Serialize and Deserialize Binary Tree",
        "slug": "serialize-and-deserialize-binary-tree-297",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Serialize and Deserialize Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Serialize and Deserialize Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Serialize and Deserialize Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-4",
        "title": "Invert Binary Tree",
        "slug": "invert-binary-tree-226",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/invert-binary-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Invert Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Invert Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Invert Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-5",
        "title": "Binary Tree Maximum Path Sum",
        "slug": "binary-tree-maximum-path-sum-124",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Maximum Path Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Maximum Path Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Maximum Path Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-6",
        "title": "Convert Sorted Array to Binary Search Tree",
        "slug": "convert-sorted-array-to-binary-search-tree-108",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Convert Sorted Array to Binary Search Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Convert Sorted Array to Binary Search Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Convert Sorted Array to Binary Search Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-7",
        "title": "Build Binary Tree from Preorder and Inorder Traversal",
        "slug": "build-binary-tree-from-preorder-and-inorder-traver",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Build Binary Tree from Preorder and Inorder Traversal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Build Binary Tree from Preorder and Inorder Traversal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Build Binary Tree from Preorder and Inorder Traversal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-8",
        "title": "Binary Tree Right Side View",
        "slug": "binary-tree-right-side-view-199",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/binary-tree-right-side-view/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Right Side View\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Right Side View\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Right Side View\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-9",
        "title": "Lowest Common Ancestor of a Binary Tree",
        "slug": "lowest-common-ancestor-of-a-binary-tree-236",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Lowest Common Ancestor of a Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Lowest Common Ancestor of a Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Lowest Common Ancestor of a Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-10",
        "title": "Validate Binary Search Tree",
        "slug": "validate-binary-search-tree-98",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/validate-binary-search-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Validate Binary Search Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Validate Binary Search Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Validate Binary Search Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-11",
        "title": "Nested List Weight Sum II",
        "slug": "nested-list-weight-sum-ii-364",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/nested-list-weight-sum-ii/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Nested List Weight Sum II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Nested List Weight Sum II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Nested List Weight Sum II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-12",
        "title": "Inorder Successor in BST",
        "slug": "inorder-successor-in-bst-285",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/inorder-successor-in-bst/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Inorder Successor in BST\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Inorder Successor in BST\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Inorder Successor in BST\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-13",
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "slug": "height-of-binary-tree-after-subtree-removal-querie",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Height of Binary Tree After Subtree Removal Queries\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Height of Binary Tree After Subtree Removal Queries\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Height of Binary Tree After Subtree Removal Queries\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-14",
        "title": "Delete Nodes And Return Forest",
        "slug": "delete-nodes-and-return-forest-1110",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/delete-nodes-and-return-forest/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Delete Nodes And Return Forest\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Delete Nodes And Return Forest\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Delete Nodes And Return Forest\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-15",
        "title": "Sum of Distances in a Tree",
        "slug": "sum-of-distances-in-a-tree-834",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/sum-of-distances-in-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sum of Distances in a Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sum of Distances in a Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sum of Distances in a Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-16",
        "title": "Recover a Tree From Preorder Traversal",
        "slug": "recover-a-tree-from-preorder-traversal-1028",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Recover a Tree From Preorder Traversal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Recover a Tree From Preorder Traversal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Recover a Tree From Preorder Traversal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-17",
        "title": "Maximum Depth of Binary Tree",
        "slug": "maximum-depth-of-binary-tree-104",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Depth of Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Depth of Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Depth of Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-18",
        "title": "Kth Smallest Element in a BST",
        "slug": "kth-smallest-element-in-a-bst-230",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
        "patternSlug": "tree-depth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Depth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Depth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Depth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Depth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Kth Smallest Element in a BST\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Kth Smallest Element in a BST\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Kth Smallest Element in a BST\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-21",
    "name": "Tree Breadth-First Search",
    "slug": "tree-breadth-first-search",
    "icon": "ðŸŒ³",
    "description": "Master the Tree Breadth-First Search pattern",
    "items": [
      {
        "id": "tre-1",
        "title": "Binary Tree Level Order Traversal",
        "slug": "binary-tree-level-order-traversal-102",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Level Order Traversal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Level Order Traversal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Level Order Traversal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-2",
        "title": "Binary Tree Zigzag Level Order Traversal",
        "slug": "binary-tree-zigzag-level-order-traversal-103",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Tree Zigzag Level Order Traversal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Tree Zigzag Level Order Traversal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Tree Zigzag Level Order Traversal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-3",
        "title": "Populating Next Right Pointers in Each Node",
        "slug": "populating-next-right-pointers-in-each-node-116",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Populating Next Right Pointers in Each Node\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Populating Next Right Pointers in Each Node\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Populating Next Right Pointers in Each Node\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-4",
        "title": "Vertical Order Traversal of a Binary Tree",
        "slug": "vertical-order-traversal-of-a-binary-tree-987",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Vertical Order Traversal of a Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Vertical Order Traversal of a Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Vertical Order Traversal of a Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-5",
        "title": "Symmetric Tree",
        "slug": "symmetric-tree-101",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/symmetric-tree/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Symmetric Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Symmetric Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Symmetric Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-6",
        "title": "Word Ladder",
        "slug": "word-ladder-127",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/word-ladder/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Ladder\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Ladder\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Ladder\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-7",
        "title": "Two Sum IV - Input Is a BST",
        "slug": "two-sum-iv-input-is-a-bst-653",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Two Sum IV - Input Is a BST\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Two Sum IV - Input Is a BST\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Two Sum IV - Input Is a BST\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-8",
        "title": "Find Minimum Diameter After Merging Two Trees",
        "slug": "find-minimum-diameter-after-merging-two-trees-3203",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Minimum Diameter After Merging Two Trees\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Minimum Diameter After Merging Two Trees\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Minimum Diameter After Merging Two Trees\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-9",
        "title": "Closest Node to Path in Tree",
        "slug": "closest-node-to-path-in-tree-3169",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/closest-node-to-path-in-tree/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Closest Node to Path in Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Closest Node to Path in Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Closest Node to Path in Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-10",
        "title": "Frog Position After T Seconds",
        "slug": "frog-position-after-t-seconds-1377",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/frog-position-after-t-seconds/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Frog Position After T Seconds\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Frog Position After T Seconds\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Frog Position After T Seconds\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-11",
        "title": "Average of Levels in Binary Tree",
        "slug": "average-of-levels-in-binary-tree-637",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/average-of-levels-in-binary-tree/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Average of Levels in Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Average of Levels in Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Average of Levels in Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tre-12",
        "title": "Connect All Siblings of a Binary Tree",
        "slug": "connect-all-siblings-of-a-binary-tree-similar-to-1",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/",
        "patternSlug": "tree-breadth-first-search",
        "theory": {
          "explanation": "This is a classic Tree Breadth-First Search problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Tree Breadth-First Search",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Tree Breadth-First Search technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Tree Breadth-First Search technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Connect All Siblings of a Binary Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Connect All Siblings of a Binary Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Connect All Siblings of a Binary Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-22",
    "name": "Trie",
    "slug": "trie",
    "icon": "ðŸ”¤",
    "description": "Master the Trie pattern",
    "items": [
      {
        "id": "tri-1",
        "title": "Implement Trie",
        "slug": "implement-trie-prefix-tree",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/implement-trie-prefix-tree/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Implement Trie\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Implement Trie\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Implement Trie\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-2",
        "title": "Search Suggestions System",
        "slug": "search-suggestions-system",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/search-suggestions-system/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Search Suggestions System\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Search Suggestions System\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Search Suggestions System\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-3",
        "title": "Replace Words",
        "slug": "replace-words",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/replace-words/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Replace Words\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Replace Words\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Replace Words\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-4",
        "title": "Design Add and Search Words Data Structure",
        "slug": "design-add-and-search-words-data-structure",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/design-add-and-search-words-data-structure/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Design Add and Search Words Data Structure\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Design Add and Search Words Data Structure\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Design Add and Search Words Data Structure\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-5",
        "title": "Word Search II",
        "slug": "word-search-ii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/word-search-ii/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Search II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Search II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Search II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-6",
        "title": "Top K Frequent Words",
        "slug": "top-k-frequent-words",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/top-k-frequent-words/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Top K Frequent Words\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Top K Frequent Words\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Top K Frequent Words\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-7",
        "title": "Longest Common Prefix",
        "slug": "longest-common-prefix",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/longest-common-prefix/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Common Prefix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Common Prefix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Common Prefix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-8",
        "title": "Index Pairs of a String",
        "slug": "index-pairs-of-a-string",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/index-pairs-of-a-string/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Index Pairs of a String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Index Pairs of a String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Index Pairs of a String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-9",
        "title": "K-th Smallest in Lexicographical Order",
        "slug": "k-th-smallest-in-lexicographical-order",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for K-th Smallest in Lexicographical Order\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for K-th Smallest in Lexicographical Order\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for K-th Smallest in Lexicographical Order\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-10",
        "title": "Palindrome Pairs",
        "slug": "palindrome-pairs",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/palindrome-pairs/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Palindrome Pairs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Palindrome Pairs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Palindrome Pairs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-11",
        "title": "Longest Common Suffix Queries",
        "slug": "longest-common-suffix-queries",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/longest-common-suffix-queries/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Common Suffix Queries\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Common Suffix Queries\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Common Suffix Queries\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-12",
        "title": "Map Sum Pairs",
        "slug": "map-sum-pairs",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/map-sum-pairs/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Map Sum Pairs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Map Sum Pairs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Map Sum Pairs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-13",
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "slug": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Check If a Word Occurs As a Prefix of Any Word in a Sentence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Check If a Word Occurs As a Prefix of Any Word in a Sentence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Check If a Word Occurs As a Prefix of Any Word in a Sentence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-14",
        "title": "Longest Word With All Prefixes",
        "slug": "longest-word-with-all-prefixes",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-word-with-all-prefixes/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Word With All Prefixes\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Word With All Prefixes\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Word With All Prefixes\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "tri-15",
        "title": "Lexicographical Numbers",
        "slug": "lexicographical-numbers",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/lexicographical-numbers/description/",
        "patternSlug": "trie",
        "theory": {
          "explanation": "This is a classic Trie problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Trie",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Trie technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Trie technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Lexicographical Numbers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Lexicographical Numbers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Lexicographical Numbers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-23",
    "name": "HashMaps",
    "slug": "hashmaps",
    "icon": "ðŸ—ºï¸",
    "description": "Master the HashMaps pattern",
    "items": [
      {
        "id": "has-1",
        "title": "Design HashMap",
        "slug": "design-hashmap",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/design-hashmap/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Design HashMap\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Design HashMap\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Design HashMap\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-2",
        "title": "Fraction to Recurring Decimal",
        "slug": "fraction-to-recurring-decimal",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/fraction-to-recurring-decimal/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Fraction to Recurring Decimal\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Fraction to Recurring Decimal\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Fraction to Recurring Decimal\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-3",
        "title": "Logger Rate Limiter",
        "slug": "logger-rate-limiter",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/logger-rate-limiter/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Logger Rate Limiter\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Logger Rate Limiter\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Logger Rate Limiter\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-4",
        "title": "Next Greater Element I",
        "slug": "next-greater-element-i",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/next-greater-element-i/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Next Greater Element I\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Next Greater Element I\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Next Greater Element I\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-5",
        "title": "Isomorphic Strings",
        "slug": "isomorphic-strings",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/isomorphic-strings/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Isomorphic Strings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Isomorphic Strings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Isomorphic Strings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-6",
        "title": "Find Duplicate File in System",
        "slug": "find-duplicate-file-in-system",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-duplicate-file-in-system/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Duplicate File in System\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Duplicate File in System\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Duplicate File in System\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-7",
        "title": "High Five",
        "slug": "high-five",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/high-five/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for High Five\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for High Five\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for High Five\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-8",
        "title": "Bulls and Cows",
        "slug": "bulls-and-cows",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/bulls-and-cows/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Bulls and Cows\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Bulls and Cows\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Bulls and Cows\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-9",
        "title": "Custom Sort String",
        "slug": "custom-sort-string",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/custom-sort-string/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Custom Sort String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Custom Sort String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Custom Sort String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-10",
        "title": "Number of Distinct Islands",
        "slug": "number-of-distinct-islands",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-distinct-islands/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Distinct Islands\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Distinct Islands\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Distinct Islands\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-11",
        "title": "Number of Wonderful Substrings",
        "slug": "number-of-wonderful-substrings",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-wonderful-substrings/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Wonderful Substrings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Wonderful Substrings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Wonderful Substrings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-12",
        "title": "Total Appeal of A String",
        "slug": "total-appeal-of-a-string",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/total-appeal-of-a-string/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Total Appeal of A String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Total Appeal of A String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Total Appeal of A String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-13",
        "title": "Continuous Subarray Sum",
        "slug": "continuous-subarray-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/continuous-subarray-sum/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Continuous Subarray Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Continuous Subarray Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Continuous Subarray Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-14",
        "title": "Unique Number of Occurrences",
        "slug": "unique-number-of-occurrences",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/unique-number-of-occurrences/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Unique Number of Occurrences\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Unique Number of Occurrences\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Unique Number of Occurrences\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-15",
        "title": "Longest Happy Prefix",
        "slug": "longest-happy-prefix",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/longest-happy-prefix/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Happy Prefix\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Happy Prefix\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Happy Prefix\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-16",
        "title": "Find Longest Self-Contained Substring",
        "slug": "find-longest-self-contained-substring",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/find-longest-self-contained-substring/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Longest Self-Contained Substring\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Longest Self-Contained Substring\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Longest Self-Contained Substring\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-17",
        "title": "Intersection of Two Arrays",
        "slug": "intersection-of-two-arrays",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/intersection-of-two-arrays/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Intersection of Two Arrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Intersection of Two Arrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Intersection of Two Arrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-18",
        "title": "Word Pattern",
        "slug": "word-pattern",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/word-pattern/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Word Pattern\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Word Pattern\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Word Pattern\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "has-19",
        "title": "Longest Palindrome",
        "slug": "longest-palindrome",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/longest-palindrome/description/",
        "patternSlug": "hashmaps",
        "theory": {
          "explanation": "This is a classic HashMaps problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to HashMaps",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how HashMaps technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using HashMaps technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Palindrome\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Palindrome\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Palindrome\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-24",
    "name": "Union Find",
    "slug": "union-find",
    "icon": "ðŸ¤",
    "description": "Master the Union Find pattern",
    "items": [
      {
        "id": "uni-1",
        "title": "Redundant Connection",
        "slug": "redundant-connection-684",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/redundant-connection/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Redundant Connection\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Redundant Connection\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Redundant Connection\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-2",
        "title": "Number of Islands",
        "slug": "number-of-islands-200",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-islands/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Islands\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Islands\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Islands\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-3",
        "title": "Most Stones Removed with Same Row or Column",
        "slug": "most-stones-removed-with-same-row-or-column-947",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Most Stones Removed with Same Row or Column\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Most Stones Removed with Same Row or Column\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Most Stones Removed with Same Row or Column\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-4",
        "title": "Longest Consecutive Sequence",
        "slug": "longest-consecutive-sequence-128",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-consecutive-sequence/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Consecutive Sequence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Consecutive Sequence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Consecutive Sequence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-5",
        "title": "Last Day Where You Can Still Cross",
        "slug": "last-day-where-you-can-still-cross-1970",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/last-day-where-you-can-still-cross/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Last Day Where You Can Still Cross\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Last Day Where You Can Still Cross\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Last Day Where You Can Still Cross\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-6",
        "title": "Regions Cut by Slashes",
        "slug": "regions-cut-by-slashes-959",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/regions-cut-by-slashes/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Regions Cut by Slashes\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Regions Cut by Slashes\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Regions Cut by Slashes\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-7",
        "title": "Accounts Merge",
        "slug": "accounts-merge-721",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/accounts-merge/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Accounts Merge\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Accounts Merge\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Accounts Merge\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-8",
        "title": "Minimize Malware Spread",
        "slug": "minimize-malware-spread-924",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimize-malware-spread/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimize Malware Spread\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimize Malware Spread\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimize Malware Spread\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-9",
        "title": "Find if Path Exists in Graph",
        "slug": "find-if-path-exists-in-graph-1971",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-if-path-exists-in-graph/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find if Path Exists in Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find if Path Exists in Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find if Path Exists in Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-10",
        "title": "The Skyline Problem",
        "slug": "the-skyline-problem-218",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/the-skyline-problem/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for The Skyline Problem\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for The Skyline Problem\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for The Skyline Problem\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-11",
        "title": "Similar String Groups",
        "slug": "similar-string-groups-839",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/similar-string-groups/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Similar String Groups\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Similar String Groups\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Similar String Groups\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-12",
        "title": "Optimize Water Distribution in a Village",
        "slug": "optimize-water-distribution-in-a-village-1168",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/optimize-water-distribution-in-a-village/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Optimize Water Distribution in a Village\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Optimize Water Distribution in a Village\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Optimize Water Distribution in a Village\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-13",
        "title": "Number of Islands II",
        "slug": "number-of-islands-ii-305",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/number-of-islands-ii/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Islands II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Islands II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Islands II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "uni-14",
        "title": "Evaluate Division",
        "slug": "evaluate-division-399",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/evaluate-division/",
        "patternSlug": "union-find",
        "theory": {
          "explanation": "This is a classic Union Find problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Union Find",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Union Find technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Union Find technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Evaluate Division\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Evaluate Division\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Evaluate Division\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-25",
    "name": "Custom Data Structures",
    "slug": "custom-data-structures",
    "icon": "ðŸ› ï¸",
    "description": "Master the Custom Data Structures pattern",
    "items": [
      {
        "id": "cus-1",
        "title": "Snapshot Array",
        "slug": "snapshot-array-1146",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/snapshot-array/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Snapshot Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Snapshot Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Snapshot Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-2",
        "title": "Time Based Key-Value Store",
        "slug": "time-based-key-value-store-981",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/time-based-key-value-store/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Time Based Key-Value Store\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Time Based Key-Value Store\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Time Based Key-Value Store\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-3",
        "title": "LRU Cache",
        "slug": "lru-cache-146",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/lru-cache/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for LRU Cache\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for LRU Cache\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for LRU Cache\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-4",
        "title": "Insert Delete GetRandom O(1)",
        "slug": "insert-delete-getrandom-o1-380",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/insert-delete-getrandom-o1/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Insert Delete GetRandom O(1)\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Insert Delete GetRandom O(1)\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Insert Delete GetRandom O(1)\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-5",
        "title": "Min Stack",
        "slug": "min-stack-155",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/min-stack/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Min Stack\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Min Stack\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Min Stack\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-6",
        "title": "Range Module",
        "slug": "range-module-715",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/range-module/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Module\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Module\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Module\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-7",
        "title": "Shortest Word Distance II",
        "slug": "shortest-word-distance-ii-244",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/shortest-word-distance-ii/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Shortest Word Distance II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Shortest Word Distance II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Shortest Word Distance II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-8",
        "title": "Design HashSet",
        "slug": "design-hashset-705",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/design-hashset/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Design HashSet\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Design HashSet\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Design HashSet\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-9",
        "title": "Max Stack",
        "slug": "max-stack-716",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/max-stack/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Max Stack\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Max Stack\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Max Stack\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-10",
        "title": "Moving Average from Data Stream",
        "slug": "moving-average-from-data-stream-346",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/moving-average-from-data-stream/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Moving Average from Data Stream\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Moving Average from Data Stream\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Moving Average from Data Stream\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-11",
        "title": "Two Sum III - Data structure design",
        "slug": "two-sum-iii-data-structure-design-170",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/two-sum-iii-data-structure-design/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Two Sum III - Data structure design\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Two Sum III - Data structure design\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Two Sum III - Data structure design\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-12",
        "title": "Range Sum Query - Immutable",
        "slug": "range-sum-query-immutable-303",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/range-sum-query-immutable/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query - Immutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query - Immutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query - Immutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-13",
        "title": "Stream of Characters",
        "slug": "stream-of-characters-1032",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/stream-of-characters/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Stream of Characters\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Stream of Characters\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Stream of Characters\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-14",
        "title": "All O`one Data Structure",
        "slug": "all-oone-data-structure-432",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/all-oone-data-structure/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for All O`one Data Structure\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for All O`one Data Structure\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for All O`one Data Structure\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-15",
        "title": "Finding MK Average",
        "slug": "finding-mk-average-1825",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/finding-mk-average/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Finding MK Average\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Finding MK Average\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Finding MK Average\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "cus-16",
        "title": "LFU Cache",
        "slug": "lfu-cache-460",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/lfu-cache/",
        "patternSlug": "custom-data-structures",
        "theory": {
          "explanation": "This is a classic Custom Data Structures problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Custom Data Structures",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Custom Data Structures technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Custom Data Structures technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for LFU Cache\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for LFU Cache\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for LFU Cache\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-26",
    "name": "Bitwise Manipulation",
    "slug": "bitwise-manipulation",
    "icon": "ðŸ’»",
    "description": "Master the Bitwise Manipulation pattern",
    "items": [
      {
        "id": "bit-1",
        "title": "Find the Difference",
        "slug": "find-the-difference-389",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-the-difference/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Difference\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Difference\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Difference\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-2",
        "title": "Complement of Base 10 Integer",
        "slug": "complement-of-base-10-integer-1009",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/complement-of-base-10-integer/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Complement of Base 10 Integer\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Complement of Base 10 Integer\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Complement of Base 10 Integer\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-3",
        "title": "Flipping an Image",
        "slug": "flipping-an-image-832",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/flipping-an-image/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Flipping an Image\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Flipping an Image\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Flipping an Image\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-4",
        "title": "Single Number",
        "slug": "single-number-136",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/single-number/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Single Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Single Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Single Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-5",
        "title": "Single Number II",
        "slug": "single-number-ii-137",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/single-number-ii/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Single Number II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Single Number II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Single Number II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-6",
        "title": "Encode and Decode Strings",
        "slug": "encode-and-decode-strings-271",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/encode-and-decode-strings/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Encode and Decode Strings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Encode and Decode Strings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Encode and Decode Strings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-7",
        "title": "Sum of All Subset XOR Totals",
        "slug": "sum-of-all-subset-xor-totals-1863",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/sum-of-all-subset-xor-totals/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sum of All Subset XOR Totals\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sum of All Subset XOR Totals\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sum of All Subset XOR Totals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-8",
        "title": "Find The K-th Lucky Number",
        "slug": "find-the-k-th-lucky-number-1922",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-good-numbers/ (closest equivalent, as the original is not on LeetCode)",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find The K-th Lucky Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find The K-th Lucky Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find The K-th Lucky Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-9",
        "title": "Minimum Number of K Consecutive Bit Flips",
        "slug": "minimum-number-of-k-consecutive-bit-flips-995",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Number of K Consecutive Bit Flips\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Number of K Consecutive Bit Flips\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Number of K Consecutive Bit Flips\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-10",
        "title": "Find the Longest Substring Having Vowels in Even Counts",
        "slug": "find-the-longest-substring-having-vowels-in-even-c",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Longest Substring Having Vowels in Even Counts\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Longest Substring Having Vowels in Even Counts\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Longest Substring Having Vowels in Even Counts\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-11",
        "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
        "slug": "count-triplets-that-can-form-two-arrays-of-equal-x",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-12",
        "title": "Longest Subarray With Maximum Bitwise AND",
        "slug": "longest-subarray-with-maximum-bitwise-and-2419",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Subarray With Maximum Bitwise AND\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Subarray With Maximum Bitwise AND\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Subarray With Maximum Bitwise AND\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-13",
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "slug": "minimum-one-bit-operations-to-make-integers-zero-1",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum One Bit Operations to Make Integers Zero\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum One Bit Operations to Make Integers Zero\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum One Bit Operations to Make Integers Zero\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-14",
        "title": "Triples with Bitwise AND Equal To Zero",
        "slug": "triples-with-bitwise-and-equal-to-zero-982",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Triples with Bitwise AND Equal To Zero\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Triples with Bitwise AND Equal To Zero\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Triples with Bitwise AND Equal To Zero\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-15",
        "title": "Power of Two",
        "slug": "power-of-two-231",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/power-of-two/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Power of Two\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Power of Two\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Power of Two\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "bit-16",
        "title": "Reverse Bits",
        "slug": "reverse-bits-190",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/reverse-bits/",
        "patternSlug": "bitwise-manipulation",
        "theory": {
          "explanation": "This is a classic Bitwise Manipulation problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Bitwise Manipulation",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Bitwise Manipulation technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Bitwise Manipulation technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Bits\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Bits\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Bits\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-27",
    "name": "Math & Geometry",
    "slug": "math-geometry",
    "icon": "ðŸ“",
    "description": "Master the Math & Geometry pattern",
    "items": [
      {
        "id": "mat-1",
        "title": "Check If It Is a Straight Line",
        "slug": "check-if-it-is-a-straight-line",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/check-if-it-is-a-straight-line/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Check If It Is a Straight Line\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Check If It Is a Straight Line\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Check If It Is a Straight Line\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-2",
        "title": "Minimum Cuts to Divide a Circle",
        "slug": "minimum-cuts-to-divide-a-circle",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/minimum-cuts-to-divide-a-circle/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Cuts to Divide a Circle\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Cuts to Divide a Circle\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Cuts to Divide a Circle\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-3",
        "title": "Rectangle Overlap",
        "slug": "rectangle-overlap",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/rectangle-overlap/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Rectangle Overlap\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Rectangle Overlap\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Rectangle Overlap\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-4",
        "title": "Minimum Time Visiting All Points",
        "slug": "minimum-time-visiting-all-points",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/minimum-time-visiting-all-points/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Time Visiting All Points\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Time Visiting All Points\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Time Visiting All Points\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-5",
        "title": "Reverse Integer",
        "slug": "reverse-integer",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/reverse-integer/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Reverse Integer\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Reverse Integer\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Reverse Integer\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-6",
        "title": "Valid Square",
        "slug": "valid-square",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/valid-square/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Valid Square\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Valid Square\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Valid Square\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-7",
        "title": "Rectangle Area",
        "slug": "rectangle-area",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/rectangle-area/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Rectangle Area\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Rectangle Area\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Rectangle Area\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-8",
        "title": "Minimum Area Rectangle",
        "slug": "minimum-area-rectangle",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-area-rectangle/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Area Rectangle\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Area Rectangle\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Area Rectangle\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-9",
        "title": "Maximum Area Rectangle With Point Constraints I",
        "slug": "maximum-area-rectangle-with-point-constraints-i",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-area-rectangle-with-point-constraints-i/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Area Rectangle With Point Constraints I\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Area Rectangle With Point Constraints I\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Area Rectangle With Point Constraints I\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-10",
        "title": "Convex Polygon",
        "slug": "convex-polygon",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/convex-polygon/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Convex Polygon\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Convex Polygon\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Convex Polygon\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-11",
        "title": "Queries on Number of Points Inside a Circle",
        "slug": "queries-on-number-of-points-inside-a-circle",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Queries on Number of Points Inside a Circle\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Queries on Number of Points Inside a Circle\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Queries on Number of Points Inside a Circle\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-12",
        "title": "Max Points on a Line",
        "slug": "max-points-on-a-line",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/max-points-on-a-line/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Max Points on a Line\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Max Points on a Line\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Max Points on a Line\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-13",
        "title": "Maximum Number of Visible Points",
        "slug": "maximum-number-of-visible-points",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/maximum-number-of-visible-points/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Number of Visible Points\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Number of Visible Points\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Number of Visible Points\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-14",
        "title": "Minimize Manhattan Distances",
        "slug": "minimize-manhattan-distances",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/minimize-manhattan-distances/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimize Manhattan Distances\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimize Manhattan Distances\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimize Manhattan Distances\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-15",
        "title": "Self Crossing",
        "slug": "self-crossing",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/self-crossing/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Self Crossing\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Self Crossing\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Self Crossing\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-16",
        "title": "Erect the Fence",
        "slug": "erect-the-fence",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/erect-the-fence/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Erect the Fence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Erect the Fence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Erect the Fence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-17",
        "title": "Minimum Number of Lines to Cover Points",
        "slug": "minimum-number-of-lines-to-cover-points",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Number of Lines to Cover Points\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Number of Lines to Cover Points\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Number of Lines to Cover Points\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-18",
        "title": "Nth Magical Number",
        "slug": "nth-magical-number",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/nth-magical-number/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Nth Magical Number\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Nth Magical Number\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Nth Magical Number\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "mat-19",
        "title": "Detonate the Maximum Bombs",
        "slug": "detonate-the-maximum-bombs",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/detonate-the-maximum-bombs/description/",
        "patternSlug": "math-geometry",
        "theory": {
          "explanation": "This is a classic Math & Geometry problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Math & Geometry",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Math & Geometry technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Math & Geometry technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Detonate the Maximum Bombs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Detonate the Maximum Bombs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Detonate the Maximum Bombs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-28",
    "name": "Extra Problems",
    "slug": "extra-problems",
    "icon": "âž•",
    "description": "Master the Extra Problems pattern",
    "items": [
      {
        "id": "ext-1",
        "title": "Shortest Bridge",
        "slug": "shortest-bridge-934",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/shortest-bridge/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Shortest Bridge\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Shortest Bridge\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Shortest Bridge\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-2",
        "title": "Number of Connected Components in an Undirected Graph",
        "slug": "number-of-connected-components-in-an-undirected-gr",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Connected Components in an Undirected Graph\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Connected Components in an Undirected Graph\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Connected Components in an Undirected Graph\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-3",
        "title": "Median of Two Sorted Arrays",
        "slug": "median-of-two-sorted-arrays-4",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Median of Two Sorted Arrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Median of Two Sorted Arrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Median of Two Sorted Arrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-4",
        "title": "Pacific Atlantic Water Flow",
        "slug": "pacific-atlantic-water-flow-417",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Pacific Atlantic Water Flow\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Pacific Atlantic Water Flow\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Pacific Atlantic Water Flow\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-5",
        "title": "Contains Duplicate",
        "slug": "contains-duplicate-217",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/contains-duplicate/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Contains Duplicate\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Contains Duplicate\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Contains Duplicate\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-6",
        "title": "Maximum Subarray",
        "slug": "maximum-subarray-53",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-subarray/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Subarray\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Subarray\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Subarray\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-7",
        "title": "Two Sum",
        "slug": "two-sum-1",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/two-sum/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Two Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Two Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Two Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-8",
        "title": "Find Minimum in Rotated Sorted Array",
        "slug": "find-minimum-in-rotated-sorted-array-153",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Minimum in Rotated Sorted Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Minimum in Rotated Sorted Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Minimum in Rotated Sorted Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-9",
        "title": "Non-overlapping Intervals",
        "slug": "non-overlapping-intervals-435",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/non-overlapping-intervals/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Non-overlapping Intervals\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Non-overlapping Intervals\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Non-overlapping Intervals\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-10",
        "title": "Meeting Rooms",
        "slug": "meeting-rooms-252",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/meeting-rooms/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Meeting Rooms\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Meeting Rooms\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Meeting Rooms\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-11",
        "title": "Largest Rectangle in Histogram",
        "slug": "largest-rectangle-in-histogram-84",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Largest Rectangle in Histogram\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Largest Rectangle in Histogram\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Largest Rectangle in Histogram\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-12",
        "title": "Subtree of Another Tree",
        "slug": "subtree-of-another-tree-572",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/subtree-of-another-tree/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Subtree of Another Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Subtree of Another Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Subtree of Another Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-13",
        "title": "Sort List",
        "slug": "sort-list-148",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/sort-list/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sort List\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sort List\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sort List\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-14",
        "title": "Number of 1 Bits",
        "slug": "number-of-1-bits-191",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/number-of-1-bits/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of 1 Bits\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of 1 Bits\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of 1 Bits\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-15",
        "title": "Container with Most Water",
        "slug": "container-with-most-water-11",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/container-with-most-water/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Container with Most Water\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Container with Most Water\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Container with Most Water\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-16",
        "title": "Evaluate Reverse Polish Notation",
        "slug": "evaluate-reverse-polish-notation-150",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Evaluate Reverse Polish Notation\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Evaluate Reverse Polish Notation\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Evaluate Reverse Polish Notation\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-17",
        "title": "4Sum",
        "slug": "4sum-18",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/4sum/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for 4Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for 4Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for 4Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-18",
        "title": "Loud and Rich",
        "slug": "loud-and-rich-851",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/loud-and-rich/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Loud and Rich\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Loud and Rich\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Loud and Rich\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-19",
        "title": "Product of Array Except Self",
        "slug": "product-of-array-except-self-238",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/product-of-array-except-self/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Product of Array Except Self\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Product of Array Except Self\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Product of Array Except Self\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-20",
        "title": "Longest Increasing Subsequence",
        "slug": "longest-increasing-subsequence-300",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-increasing-subsequence/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Increasing Subsequence\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Increasing Subsequence\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Increasing Subsequence\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-21",
        "title": "Sum of Two Integers",
        "slug": "sum-of-two-integers-371",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/sum-of-two-integers/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Sum of Two Integers\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Sum of Two Integers\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Sum of Two Integers\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-22",
        "title": "Majority Element",
        "slug": "majority-element-169",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/majority-element/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Majority Element\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Majority Element\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Majority Element\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-23",
        "title": "Unique Paths",
        "slug": "unique-paths-62",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/unique-paths/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Unique Paths\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Unique Paths\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Unique Paths\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-24",
        "title": "Longest Palindromic Substring",
        "slug": "longest-palindromic-substring-5",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/longest-palindromic-substring/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Palindromic Substring\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Palindromic Substring\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Palindromic Substring\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-25",
        "title": "Permutations II",
        "slug": "permutations-ii-47",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/permutations-ii/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Permutations II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Permutations II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Permutations II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-26",
        "title": "Number of Provinces",
        "slug": "number-of-provinces-547",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-provinces/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Provinces\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Provinces\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Provinces\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-27",
        "title": "Linked List Cycle II",
        "slug": "linked-list-cycle-ii-142",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/linked-list-cycle-ii/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Linked List Cycle II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Linked List Cycle II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Linked List Cycle II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-28",
        "title": "Minimum Flips to Make the Binary String Alternate",
        "slug": "minimum-flips-to-make-the-binary-string-alternate-",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Flips to Make the Binary String Alternate\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Flips to Make the Binary String Alternate\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Flips to Make the Binary String Alternate\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-29",
        "title": "Lemonade Change",
        "slug": "lemonade-change-860",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/lemonade-change/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Lemonade Change\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Lemonade Change\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Lemonade Change\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-30",
        "title": "House Robber",
        "slug": "house-robber-198",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/house-robber/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for House Robber\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for House Robber\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for House Robber\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-31",
        "title": "Find All Numbers Disappeared in an Array",
        "slug": "find-all-numbers-disappeared-in-an-array-448",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find All Numbers Disappeared in an Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find All Numbers Disappeared in an Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find All Numbers Disappeared in an Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-32",
        "title": "Same Tree",
        "slug": "same-tree-100",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/same-tree/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Same Tree\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Same Tree\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Same Tree\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-33",
        "title": "Find All Duplicates in an Array",
        "slug": "find-all-duplicates-in-an-array-442",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find All Duplicates in an Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find All Duplicates in an Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find All Duplicates in an Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-34",
        "title": "Design In-Memory File System",
        "slug": "design-in-memory-file-system-588",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/design-in-memory-file-system/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Design In-Memory File System\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Design In-Memory File System\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Design In-Memory File System\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-35",
        "title": "Design File System",
        "slug": "design-file-system-1166",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/design-file-system/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Design File System\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Design File System\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Design File System\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-36",
        "title": "Asteroid Collision",
        "slug": "asteroid-collision-735",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/asteroid-collision/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Asteroid Collision\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Asteroid Collision\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Asteroid Collision\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-37",
        "title": "Rotting Oranges",
        "slug": "rotting-oranges-994",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/rotting-oranges/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Rotting Oranges\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Rotting Oranges\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Rotting Oranges\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-38",
        "title": "Add Binary",
        "slug": "add-binary-67",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/add-binary/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Add Binary\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Add Binary\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Add Binary\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "ext-39",
        "title": "Multiply Strings",
        "slug": "multiply-strings-43",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/multiply-strings/",
        "patternSlug": "extra-problems",
        "theory": {
          "explanation": "This is a classic Extra Problems problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Extra Problems",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Extra Problems technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Extra Problems technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Multiply Strings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Multiply Strings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Multiply Strings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-29",
    "name": "Segment Trees",
    "slug": "segment-trees",
    "icon": "ðŸŒ´",
    "description": "Master the Segment Trees pattern",
    "items": [
      {
        "id": "seg-1",
        "title": "Range Sum Query - Immutable",
        "slug": "range-sum-query-immutable",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/range-sum-query-immutable/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query - Immutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query - Immutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query - Immutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-2",
        "title": "Range Sum Query - Mutable",
        "slug": "range-sum-query-mutable",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-sum-query-mutable/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query - Mutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query - Mutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query - Mutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-3",
        "title": "Range Addition",
        "slug": "range-addition",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-addition/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Addition\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Addition\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Addition\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-4",
        "title": "Car Pooling",
        "slug": "car-pooling",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/car-pooling/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        vector<int> stops(1001, 0);\n        for (auto& t : trips) {\n            stops[t[1]] += t[0];\n            stops[t[2]] -= t[0];\n        }\n        int cur = 0;\n        for (int i : stops) {\n            cur += i;\n            if (cur > capacity) return false;\n        }\n        return true;\n    }\n};",
            "java": "class Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        int[] buckets = new int[1001];\n        \n        for (int[] trip : trips) {\n            int numPassengers = trip[0];\n            int start = trip[1];\n            int end = trip[2];\n            buckets[start] += numPassengers;\n            buckets[end] -= numPassengers;\n        }\n        \n        int passengers = 0;\n        for (int bucket : buckets) {\n            passengers += bucket;\n            if (passengers > capacity) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
            "python": "# Python Solution for Car Pooling\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-5",
        "title": "Falling Squares",
        "slug": "falling-squares",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/falling-squares/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Falling Squares\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Falling Squares\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Falling Squares\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-6",
        "title": "My Calendar III",
        "slug": "my-calendar-iii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/my-calendar-iii/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "class MyCalendarThree {\n    map<int, int> mp;\npublic:\n    MyCalendarThree() { }\n\n    int book(int startTime, int endTime) {\n        mp[startTime]++;\n        mp[endTime]--;\n        \n        int cur = 0, k = 0;\n        for (auto& [t, cnt] : mp) {\n            cur += cnt;\n            k = max(k, cur);\n        }\n        return k;\n    }\n};",
            "java": "class MyCalendarThree {\n    Map<Integer, Integer> map;\n\n    public MyCalendarThree() {\n        map = new TreeMap<>();\n    }\n\n    public int book(int startTime, int endTime) {\n        map.put(startTime, map.getOrDefault(startTime, 0) + 1);\n        map.put(endTime, map.getOrDefault(endTime, 0) - 1);\n        \n        int bookings = 0;\n        int max = 0;\n        \n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            bookings += entry.getValue();\n            max = Math.max(max, bookings);\n        }\n        return max;\n    }\n}",
            "python": "# Python Solution for My Calendar III\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-7",
        "title": "Maximum Sum Queries",
        "slug": "maximum-sum-queries",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/maximum-sum-queries/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Sum Queries\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Sum Queries\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Sum Queries\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-8",
        "title": "Range Sum Query 2D - Mutable",
        "slug": "range-sum-query-2d-mutable",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-sum-query-2d-mutable/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query 2D - Mutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query 2D - Mutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query 2D - Mutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-9",
        "title": "Count of Range Sum",
        "slug": "count-of-range-sum",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/count-of-range-sum/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count of Range Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count of Range Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count of Range Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-10",
        "title": "Range Frequency Queries",
        "slug": "range-frequency-queries",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-frequency-queries/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Frequency Queries\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Frequency Queries\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Frequency Queries\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "seg-11",
        "title": "Longest Increasing Subsequence II",
        "slug": "longest-increasing-subsequence-ii",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/longest-increasing-subsequence-ii/description/",
        "patternSlug": "segment-trees",
        "theory": {
          "explanation": "This is a classic Segment Trees problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Segment Trees",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Segment Trees technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Segment Trees technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Longest Increasing Subsequence II\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Longest Increasing Subsequence II\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Longest Increasing Subsequence II\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  },
  {
    "id": "pattern-30",
    "name": "Prefix Sum",
    "slug": "prefix-sum",
    "icon": "âž•",
    "description": "Master the Prefix Sum pattern",
    "items": [
      {
        "id": "pre-1",
        "title": "Running Sum of 1d Array",
        "slug": "running-sum-of-1d-array",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/running-sum-of-1d-array/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Running Sum of 1d Array\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Running Sum of 1d Array\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Running Sum of 1d Array\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-2",
        "title": "Range Sum Query - Immutable",
        "slug": "range-sum-query-immutable",
        "difficulty": "easy",
        "externalLink": "https://leetcode.com/problems/range-sum-query-immutable/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query - Immutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query - Immutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query - Immutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-3",
        "title": "Subarray Sum Equals K",
        "slug": "subarray-sum-equals-k",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/subarray-sum-equals-k/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Subarray Sum Equals K\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Subarray Sum Equals K\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Subarray Sum Equals K\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-4",
        "title": "XOR Queries of a Subarray",
        "slug": "xor-queries-of-a-subarray",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/xor-queries-of-a-subarray/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for XOR Queries of a Subarray\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for XOR Queries of a Subarray\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for XOR Queries of a Subarray\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-5",
        "title": "Count Vowel Strings in Ranges",
        "slug": "count-vowel-strings-in-ranges",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-vowel-strings-in-ranges/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Vowel Strings in Ranges\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Vowel Strings in Ranges\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Vowel Strings in Ranges\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-6",
        "title": "Maximum Size Subarray Sum Equals k",
        "slug": "maximum-size-subarray-sum-equals-k",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Size Subarray Sum Equals k\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Size Subarray Sum Equals k\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Size Subarray Sum Equals k\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-7",
        "title": "Count Number of Nice Subarrays",
        "slug": "count-number-of-nice-subarrays",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-number-of-nice-subarrays/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Number of Nice Subarrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Number of Nice Subarrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Number of Nice Subarrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-8",
        "title": "Binary Subarrays With Sum",
        "slug": "binary-subarrays-with-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/binary-subarrays-with-sum/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Binary Subarrays With Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Binary Subarrays With Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Binary Subarrays With Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-9",
        "title": "Count Number of Bad Pairs",
        "slug": "count-number-of-bad-pairs",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-number-of-bad-pairs/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Number of Bad Pairs\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Number of Bad Pairs\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Number of Bad Pairs\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-10",
        "title": "Minimum Operations to Reduce X to Zero",
        "slug": "minimum-operations-to-reduce-x-to-zero",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Minimum Operations to Reduce X to Zero\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Minimum Operations to Reduce X to Zero\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Minimum Operations to Reduce X to Zero\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-11",
        "title": "Subarray Sums Divisible by K",
        "slug": "subarray-sums-divisible-by-k",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/subarray-sums-divisible-by-k/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Subarray Sums Divisible by K\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Subarray Sums Divisible by K\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Subarray Sums Divisible by K\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-12",
        "title": "Check If Array Pairs Are Divisible by k",
        "slug": "check-if-array-pairs-are-divisible-by-k",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Check If Array Pairs Are Divisible by k\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Check If Array Pairs Are Divisible by k\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Check If Array Pairs Are Divisible by k\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-13",
        "title": "Make Sum Divisible by P",
        "slug": "make-sum-divisible-by-p",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/make-sum-divisible-by-p/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Make Sum Divisible by P\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Make Sum Divisible by P\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Make Sum Divisible by P\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-14",
        "title": "Continuous Subarray Sum",
        "slug": "continuous-subarray-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/continuous-subarray-sum/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Continuous Subarray Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Continuous Subarray Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Continuous Subarray Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-15",
        "title": "Find the Divisibility Array of a String",
        "slug": "find-the-divisibility-array-of-a-string",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-divisibility-array-of-a-string/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Divisibility Array of a String\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Divisibility Array of a String\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Divisibility Array of a String\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-16",
        "title": "Count of Interesting Subarrays",
        "slug": "count-of-interesting-subarrays",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-of-interesting-subarrays/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count of Interesting Subarrays\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count of Interesting Subarrays\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count of Interesting Subarrays\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-17",
        "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
        "slug": "count-triplets-that-can-form-two-arrays-of-equal-x",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Triplets That Can Form Two Arrays of Equal XOR\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-18",
        "title": "Number of Wonderful Substrings",
        "slug": "number-of-wonderful-substrings",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/number-of-wonderful-substrings/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Number of Wonderful Substrings\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Number of Wonderful Substrings\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Number of Wonderful Substrings\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-19",
        "title": "Find Longest Awesome Substring",
        "slug": "find-longest-awesome-substring",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-longest-awesome-substring/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find Longest Awesome Substring\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find Longest Awesome Substring\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find Longest Awesome Substring\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-20",
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "slug": "find-the-longest-substring-containing-vowels-in-ev",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Find the Longest Substring Containing Vowels in Even Counts\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Find the Longest Substring Containing Vowels in Even Counts\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Find the Longest Substring Containing Vowels in Even Counts\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-21",
        "title": "Range Sum Query 2D - Immutable",
        "slug": "range-sum-query-2d-immutable",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/range-sum-query-2d-immutable/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Range Sum Query 2D - Immutable\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Range Sum Query 2D - Immutable\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Range Sum Query 2D - Immutable\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-22",
        "title": "Matrix Block Sum",
        "slug": "matrix-block-sum",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/matrix-block-sum/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Matrix Block Sum\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Matrix Block Sum\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Matrix Block Sum\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-23",
        "title": "Stamping the Grid",
        "slug": "stamping-the-grid",
        "difficulty": "hard",
        "externalLink": "https://leetcode.com/problems/stamping-the-grid/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Stamping the Grid\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Stamping the Grid\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Stamping the Grid\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-24",
        "title": "Maximal Square",
        "slug": "maximal-square",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximal-square/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximal Square\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximal Square\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximal Square\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-25",
        "title": "Count Artifacts That Can Be Extracted",
        "slug": "count-artifacts-that-can-be-extracted",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/count-artifacts-that-can-be-extracted/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Count Artifacts That Can Be Extracted\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Count Artifacts That Can Be Extracted\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Count Artifacts That Can Be Extracted\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-26",
        "title": "Maximum Difference Score in a Grid",
        "slug": "maximum-difference-score-in-a-grid",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/maximum-difference-score-in-a-grid/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Maximum Difference Score in a Grid\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Maximum Difference Score in a Grid\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Maximum Difference Score in a Grid\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      },
      {
        "id": "pre-27",
        "title": "Grid Game",
        "slug": "grid-game",
        "difficulty": "medium",
        "externalLink": "https://leetcode.com/problems/grid-game/",
        "patternSlug": "prefix-sum",
        "theory": {
          "explanation": "This is a classic Prefix Sum problem. Understanding the pattern will help you solve similar problems efficiently.",
          "whenToUse": [
            "When you encounter problems related to Prefix Sum",
            "When brute force solution has higher time complexity",
            "When you need to optimize space or time"
          ],
          "intuition": "Think about how Prefix Sum technique can be applied to break down this problem.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "edgeCases": [
            "Empty input",
            "Single element",
            "All elements same",
            "Already sorted"
          ]
        },
        "solutions": {
          "approaches": [
            {
              "name": "Brute Force",
              "description": "Simple but less efficient",
              "complexity": {
                "time": "O(nÂ²)",
                "space": "O(1)"
              }
            },
            {
              "name": "Optimized",
              "description": "Using Prefix Sum technique",
              "complexity": {
                "time": "O(n)",
                "space": "O(1)"
              }
            }
          ],
          "code": {
            "cpp": "// C++ Solution for Grid Game\nclass Solution {\npublic:\n    void solve() {\n        // TODO: Implement\n    }\n};",
            "java": "// Java Solution for Grid Game\nclass Solution {\n    public void solve() {\n        // TODO: Implement\n    }\n}",
            "python": "# Python Solution for Grid Game\nclass Solution:\n    def solve(self):\n        # TODO: Implement\n        pass"
          }
        }
      }
    ]
  }
];

export const getPatternBySlug = (slug) => {
  return dsaPatterns.find(p => p.slug === slug);
};

// Helper function to get a problem by pattern and problem slug
export const getProblemBySlug = (patternSlug, problemSlug) => {
  const pattern = getPatternBySlug(patternSlug);
  if (!pattern) return null;
  return pattern.items.find(p => p.slug === problemSlug);
};

// Helper function to get all patterns
export const getAllPatterns = () => dsaPatterns;

// Helper function to get all items across all patterns
export const getAllItems = () => {
  return dsaPatterns.flatMap(pattern =>
    pattern.items.map(item => ({
      ...item,
      patternSlug: pattern.slug,
      patternName: pattern.name
    }))
  );
};

// Helper function to calculate progress
export const calculateProgress = (completedItems = []) => {
  const completedSet = new Set(completedItems);

  let total = 0;
  let solved = 0;
  let easy = { total: 0, solved: 0 };
  let medium = { total: 0, solved: 0 };
  let hard = { total: 0, solved: 0 };

  dsaPatterns.forEach(pattern => {
    pattern.items.forEach(item => {
      // Skip theory items from counting
      if (item.difficulty === 'theory') return;

      total++;
      const isCompleted = completedSet.has(item.id) || completedSet.has(item.slug);
      if (isCompleted) solved++;

      if (item.difficulty === 'easy') {
        easy.total++;
        if (isCompleted) easy.solved++;
      } else if (item.difficulty === 'medium') {
        medium.total++;
        if (isCompleted) medium.solved++;
      } else if (item.difficulty === 'hard') {
        hard.total++;
        if (isCompleted) hard.solved++;
      }
    });
  });

  return {
    total,
    solved,
    percentage: total > 0 ? Math.round((solved / total) * 100) : 0,
    easy,
    medium,
    hard
  };
};

// Helper function to get an item by slug
export const getItemBySlug = (patternSlug, itemSlug) => {
  const pattern = dsaPatterns.find(p => p.slug === patternSlug);
  if (!pattern) return null;

  const item = pattern.items.find(i => i.slug === itemSlug);
  if (!item) return null;

  return {
    ...item,
    patternSlug: pattern.slug,
    patternName: pattern.name
  };
};